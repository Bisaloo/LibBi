[%-ClassName = "${Name}Model" | ucfirst-%]
[%-PriorTypes = [ 'D', 'C', 'P' ]-%]

[%-USE DBI(dbh = dbh)-%]

[%-GetNodes = DBI.prepare("SELECT Name, HasX, HasY, HasZ FROM Node WHERE Category <> 'Intermediate result' AND Category <> 'Constant' ORDER BY Position ASC")-%]
[%-GetDistinctNodes = DBI.prepare("SELECT DISTINCT Name FROM Node WHERE Category <> 'Intermediate result' AND Category <> 'Constant' ORDER BY Position ASC")-%]
[%-GetNodesWithTrait = DBI.prepare('SELECT * FROM Node, NodeTrait WHERE Trait = ? AND NodeTrait.Node = Node.Name')-%]
[%-GetNodesWithPrior = DBI.prepare("SELECT DISTINCT Name, Position, Trait FROM Node, NodeTrait WHERE Trait LIKE 'HAS_%_PRIOR' AND NodeTrait.Node = Node.Name INTERSECT SELECT Name, Position, Trait FROM Node, NodeTrait WHERE Trait = ? AND NodeTrait.Node = Node.Name ORDER BY Position")-%]
[%-GetParentsWithTrait = DBI.prepare("SELECT DISTINCT Parent.ParentNode, Parent.ChildNode, Parent.XOffset, Parent.YOffset, Parent.ZOffset, Parent.Position FROM Parent, Node, NodeTrait WHERE NodeTrait.Trait = ? AND NodeTrait.Node = Parent.ParentNode AND Parent.ChildNode = Node.Name ORDER BY Node.Position, Parent.Position")-%]
[%-GetEdges = DBI.prepare("SELECT DISTINCT Parent.ParentNode, Parent.ChildNode, Parent.XOffset, Parent.YOffset, Parent.ZOffset FROM Node, Parent WHERE Node.Category <> 'Intermediate result' AND Node.Category <> 'Constant' AND Parent.ParentNode = Node.Name ORDER BY Parent.Position")-%]
[%-CheckTrait = DBI.prepare('SELECT 1 FROM NodeTrait WHERE Node = ? AND Trait = ?')-%]
[%-CheckTraits2 = DBI.prepare('SELECT 1 FROM NodeTrait WHERE Node = ? AND Trait IN (?,?)')-%]
[%-CheckTraits3 = DBI.prepare('SELECT DISTINCT 1 FROM NodeTrait WHERE Node = ? AND Trait IN (?,?,?)')-%]

/**
 * @file
 *
 * @author Generated by spec2x
 * $Rev$
 * $Date$
 */
#ifndef BIM_[% ClassName | upper %]_HPP
#define BIM_[% ClassName | upper %]_HPP

[% FOREACH Node = GetDistinctNodes.execute-%]
#include "[% Node.Name | ucfirst %]Node.hpp"
[% END-%]

#include "bi/model/BayesNet.hpp"
#include "bi/model/model.hpp"
#include "bi/typelist/macro_typelist.hpp"
#include "bi/pdf/FactoredPdf.hpp"
#include "bi/pdf/ExpGaussianPdf.hpp"
#include "bi/pdf/UniformPdf.hpp"
#include "bi/pdf/GammaPdf.hpp"
#include "bi/pdf/InverseGammaPdf.hpp"

#include <vector>

[% FOREACH Type IN [ 'S', 'D', 'C', 'R', 'F', 'O', 'P' ]-%]
/**
 * Type list for [% Type | lower %]-nodes.
 */
BEGIN_TYPELIST([% Name %][% Type %]TypeList)
[% FOREACH Node = GetNodesWithTrait.execute("IS_${Type}_NODE")-%]
SINGLE_TYPE(1, [% Node.Name | ucfirst %]Node)
[% END-%]
END_TYPELIST()

[% END-%]

[%-FOREACH Type IN [ 'S', 'D', 'C', 'R', 'F', 'P'] %]
/* [% Type | lower %]-parents */
[% FOREACH Parent = GetParentsWithTrait.execute("IS_${Type}_NODE")-%]
SET_PA([% Type | lower %], [% Parent.ChildNode | ucfirst %]Node, [% Parent.Position %], [% Parent.ParentNode | ucfirst %]Node, [% Parent.XOffset %], [% Parent.YOffset %], [% Parent.ZOffset %])
[% END-%]
[% END-%]

[%-FOREACH Type IN PriorTypes %]
BEGIN_TYPELIST([% Name %][% Type %]PriorTypeList)
[% FOREACH Node = GetNodesWithTrait.execute("IS_${Type}_NODE")-%]
[%-FOREACH CheckTrait.execute(Node.Name, 'HAS_UNIFORM_PRIOR')-%]
SINGLE_TYPE(bi::node_dimlens<[% Node.Name | ucfirst %]Node>::value, bi::UniformPdf<>)
[% END-%]
[%-FOREACH CheckTraits3.execute(Node.Name, 'HAS_GAUSSIAN_PRIOR', 'HAS_NORMAL_PRIOR', 'HAS_LOG_NORMAL_PRIOR')-%]
SINGLE_TYPE(bi::node_dimlens<[% Node.Name | ucfirst %]Node>::value, bi::ExpGaussianPdf<>)
[% END-%]
[%-FOREACH CheckTrait.execute(Node.Name, 'HAS_GAMMA_PRIOR')-%]
SINGLE_TYPE(bi::node_dimlens<[% Node.Name | ucfirst %]Node>::value, bi::GammaPdf)
[% END-%]
[%-FOREACH CheckTrait.execute(Node.Name, 'HAS_INVERSE_GAMMA_PRIOR')-%]
SINGLE_TYPE(bi::node_dimlens<[% Node.Name | ucfirst %]Node>::value, bi::InverseGammaPdf)
[% END-%]
[%-END-%]
END_TYPELIST()

[% END-%]

/**
 * Prior type selector for [% ClassName %].
 *
 * @tparam type Node type.
 */
template<bi::NodeType type>
struct [% ClassName %]PriorType {
  //
};

[%-FOREACH Type IN PriorTypes %]
template<>
struct [% ClassName %]PriorType<bi::[% Type %]_NODE> {
  typedef bi::FactoredPdf<GET_TYPELIST([% Name %][% Type %]PriorTypeList)> type; 
};
[% END-%]

/**
 * [% Description %]
 *
 * @tparam XN Size of x-dimension.
 * @tparam YN Size of y-dimension.
 * @tparam ZN Size of z-dimension.
 */
template<int XN = 1, int YN = 1, int ZN = 1>
class [% ClassName %] : public bi::BayesNet {
public:
  [%-FOREACH Type IN [ 'S', 'D', 'C', 'R', 'F', 'O', 'P' ] %]
  /**
   * Type list for [% Type | lower %]-net.
   */
  typedef GET_TYPELIST([% Name %][% Type %]TypeList) [% Type %]TypeList;
  [% END-%]

  [%-FOREACH Type IN PriorTypes %]
  /**
   * Type list for factored prior over [% Type | lower %]-net.
   */
  typedef typename [% ClassName %]PriorType<bi::[% Type %]_NODE>::type [% Type %]PriorType;
  [% END-%]
  
  [%-FOREACH Dim IN [ 'X', 'Y', 'Z' ] %]
  /**
   * Size of [% Dim | lower %]-dimension.
   */
  static const int N[% Dim %] = [% Dim %]N;
  [% END-%]

  /**
   * Constructor.
   */
  [% ClassName %]();
  
  /**
   * Destructor.
   */
  ~[% ClassName %]();

  /**
   * Get prior over nodes of given type.
   *
   * @tparam type Node type.
   *
   * @return Prior over nodes of given type.
   */
  template<bi::NodeType type>
  const typename [% ClassName %]PriorType<type>::type& getPrior() const;

  /**
   * Get prior over nodes of given type.
   *
   * @tparam type Node type.
   *
   * @return Prior over nodes of given type.
   */
  template<bi::NodeType type>
  typename [% ClassName %]PriorType<type>::type& getPrior();

private:
  /*
   * Nodes.
   */
  [% FOREACH Node = GetNodes.execute-%]
  [%-Node.Name | ucfirst %]Node node[% Node.Name %];
  [% END-%]

  /**
   * Priors.
   */
  std::vector<void*> priors;

};

#include "bi/traits/prior_traits.hpp"
#include "bi/traits/likelihood_traits.hpp"
#include "bi/math/host_vector.hpp"
#include "bi/math/host_matrix.hpp"

template<int XN, int YN, int ZN>
[% ClassName %]<XN,YN,ZN>::[% ClassName %]() : priors(bi::NUM_NODE_TYPES, NULL) {
  using namespace bi;
  int i;

  init<[% ClassName %]>();

  /* nodes */
  [%-FOREACH Node = GetNodes.execute %]
  addNode<[% ClassName %],[% Node.Name | ucfirst %]Node>(node[% Node.Name %]);
  [%-END %]

  /* edges */
  [%-FOREACH Edge = GetEdges.execute %]
  addArc(node[% Edge.ParentNode %], node[% Edge.ChildNode %], [% Edge.XOffset %], [% Edge.YOffset %], [% Edge.ZOffset %]);
  [%-END %]

  /* priors */ 
  [%-FOREACH Type IN PriorTypes %]
  priors[[% Type %]_NODE] = new typename [% ClassName %]PriorType<[% Type %]_NODE>::type();
  [%-END %]
  
  [%-FOREACH Type IN PriorTypes-%]
  [%-FOREACH Node = GetNodesWithTrait.execute("IS_${Type}_NODE")-%]
  [%-Position = loop.index-%]
  [%-FOREACH CheckTrait.execute(Node.Name, 'HAS_UNIFORM_PRIOR') %]
  UniformPdf<> [% Type | lower %][% Position %](node[% Node.Name %].lower0(), node[% Node.Name %].upper0());
  for (i = 0; i < getNodeSize([% Type %]_NODE, [% Position %]); ++i) {
    getPrior<[% Type %]_NODE>().set(getNodeStart([% Type %]_NODE, [% Position %]) + i, [% Type | lower %][% Position %]);
  }
  [% END-%]
  [%-FOREACH CheckTraits2.execute(Node.Name, 'HAS_GAUSSIAN_PRIOR', 'HAS_NORMAL_PRIOR') %]
  ExpGaussianPdf<> [% Type | lower %][% Position %](node[% Node.Name %].mu0(), std::pow(node[% Node.Name %].sigma0(), 2));
  for (i = 0; i < getNodeSize([% Type %]_NODE, [% Position %]); ++i) {
    getPrior<[% Type %]_NODE>().set(getNodeStart([% Type %]_NODE, [% Position %]) + i, [% Type | lower %][% Position %]);
  }
  [% END-%]
  [%-FOREACH CheckTrait.execute(Node.Name, 'HAS_LOG_NORMAL_PRIOR') %]
  ExpGaussianPdf<> [% Type | lower %][% Position %](node[% Node.Name %].mu0(), std::pow(node[% Node.Name %].sigma0(), 2), true);
  for (i = 0; i < getNodeSize([% Type %]_NODE, [% Position %]); ++i) {
    getPrior<[% Type %]_NODE>().set(getNodeStart([% Type %]_NODE, [% Position %]) + i, [% Type | lower %][% Position %]);
  }
  [% END-%]
  [%-FOREACH CheckTrait.execute(Node.Name, 'HAS_GAMMA_PRIOR') %]
  GammaPdf [% Type | lower %][% Position %](node[% Node.Name %].alpha0(), node[% Node.Name %].beta0(), true);
  for (i = 0; i < getNodeSize([% Type %]_NODE, [% Position %]); ++i) {
    getPrior<[% Type %]_NODE>().set(getNodeStart([% Type %]_NODE, [% Position %]) + i, [% Type | lower %][% Position %]);
  }
  [% END-%]
  [%-FOREACH CheckTrait.execute(Node.Name, 'HAS_INVERSE_GAMMA_PRIOR') %]
  InverseGammaPdf [% Type | lower %][% Position %](node[% Node.Name %].alpha0(), node[% Node.Name %].beta0(), true);
  for (i = 0; i < getNodeSize([% Type %]_NODE, [% Position %]); ++i) {
    getPrior<[% Type %]_NODE>().set(getNodeStart([% Type %]_NODE, [% Position %]) + i, [% Type | lower %][% Position %]);
  }
  [% END-%]
  [%-END-%]
  [% END %]
}

template<int XN, int YN, int ZN>
[% ClassName %]<XN,YN,ZN>::~[% ClassName %]() {
  using namespace bi;

  delete &getPrior<D_NODE>();
  delete &getPrior<C_NODE>();
  delete &getPrior<P_NODE>();
}

template<int XN, int YN, int ZN>
template<bi::NodeType type>
inline typename [% ClassName %]PriorType<type>::type& [% ClassName %]<XN,YN,ZN>::getPrior() {
  using namespace bi;

  /* pre-condition */
  assert ([%-FOREACH Type IN PriorTypes %]type == [% Type %]_NODE || [% END-%]false);

  return *static_cast<typename [% ClassName %]PriorType<type>::type*>(priors[type]);
}

template<int XN, int YN, int ZN>
template<bi::NodeType type>
inline const typename [% ClassName %]PriorType<type>::type& [% ClassName %]<XN,YN,ZN>::getPrior() const {
  using namespace bi;

  /* pre-condition */
  assert ([%-FOREACH Type IN PriorTypes %]type == [% Type %]_NODE || [% END-%]false);

  return *static_cast<typename [% ClassName %]PriorType<type>::type*>(priors[type]);
}

#endif
