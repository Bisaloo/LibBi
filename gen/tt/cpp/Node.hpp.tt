[%-ClassName = "${Name}Node" | ucfirst -%]

[%-#Translation of variable names with dimensions-%]
[%-BLOCK Variable-%]
[%-Name-%]
[%-IF XOffset != '' && XOffset > 0 %]_xp[% XOffset %][% END-%]
[%-IF XOffset != '' && XOffset < 0 %]_xm[% XOffset | remove('-') %][% END-%]
[%-IF YOffset != '' && YOffset > 0 %]_yp[% YOffset %][% END-%]
[%-IF YOffset != '' && YOffset < 0 %]_ym[% YOffset | remove('-') %][% END-%]
[%-IF ZOffset != '' && ZOffset > 0 %]_zp[% ZOffset %][% END-%]
[%-IF ZOffset != '' && ZOffset < 0 %]_zm[% ZOffset | remove('-') %][% END-%]
[%-END-%]

[%-#Database-%]
[%-USE DBI(dbh = dbh)-%]

[%-GetTraits = DBI.prepare('SELECT Trait AS "Name" FROM NodeTrait WHERE Node = ?')-%]

[%-CheckTrait = DBI.prepare('SELECT 1 FROM NodeTrait WHERE Node = ? AND Trait = ?')-%]
[%-CheckTraits2 = DBI.prepare('SELECT DISTINCT 1 FROM NodeTrait WHERE Node = ? AND Trait IN (?,?)')-%]
[%-CheckTraits3 = DBI.prepare('SELECT DISTINCT 1 FROM NodeTrait WHERE Node = ? AND Trait IN (?,?,?)')-%]
[%-CheckTraits4 = DBI.prepare('SELECT DISTINCT 1 FROM NodeTrait WHERE Node = ? AND Trait IN (?,?,?,?)')-%]

[%-GetDistinctParents = DBI.prepare('SELECT DISTINCT ParentNode AS "Name" FROM Parent, Node, NodeTrait WHERE Parent.ChildNode = ? AND NodeTrait.Trait = ? AND Parent.ParentNode = Node.Name AND NodeTrait.Node = Node.Name ORDER BY Parent.Position')-%]

[%-GetParents = DBI.prepare('SELECT ParentNode AS "Name", XOffset, YOffset, ZOffset FROM Parent, Node, NodeTrait WHERE Parent.ChildNode = ? AND NodeTrait.Trait = ? AND Parent.ParentNode = Node.Name AND NodeTrait.Node = Node.Name ORDER BY Parent.Position')-%]

[%-GetConstantParents = DBI.prepare('SELECT ParentNode AS "Name", XOffset, YOffset, ZOffset, GROUP_CONCAT(NodeFormula.Formula) AS "Formula", COUNT(NodeFormula.Formula) AS "NumFormulas" FROM Parent, Node, NodeFormula WHERE Parent.ChildNode = ? AND Node.Category = \'Constant\' AND Parent.ParentNode = Node.Name AND NodeFormula.Node = Node.Name GROUP BY ParentNode, XOffset, YOffset, ZOffset ORDER BY Parent.Position')-%]

[%-GetInlineParents = DBI.prepare('SELECT ParentNode AS "Name", XOffset, YOffset, ZOffset, GROUP_CONCAT(NodeFormula.Formula) AS "Formula", COUNT(NodeFormula.Formula) AS "NumFormulas" FROM Parent, Node, NodeFormula WHERE Parent.ChildNode = ? AND Node.Category = \'Intermediate result\' AND Parent.ParentNode = Node.Name AND NodeFormula.Node = Node.Name GROUP BY ParentNode, XOffset, YOffset, ZOffset ORDER BY Parent.Position')-%]

[%-GetFormulae = DBI.prepare('SELECT Function, Formula, XOrdinate, YOrdinate, ZOrdinate FROM NodeFormula WHERE Node = ? AND Function = ? ORDER BY Position')-%]
/**
 * @file
 *
 * @author Generated by spec2x
 * $Rev$
 * $Date$
 */
#ifndef BIM_[% ClassName | upper %]_HPP
#define BIM_[% ClassName | upper %]_HPP

#include "bi/model/BayesNode.hpp"
#include "bi/state/Coord.hpp"
#include "bi/cuda/cuda.hpp"
#include "bi/math/scalar.hpp"
#include "bi/misc/compile.hpp"

#ifdef USE_SSE
#include "bi/math/sse.hpp" // overloads of standard math functions
#endif

/**
 * \f\$[% Name | latexexp %]\f\$; [% Description %]
 */
class [% ClassName %] : public bi::BayesNode {
public:
  /**
   * Constructor.
   */
  [% ClassName %]();

  [%-FOREACH CheckTrait.execute(Name, 'IS_ODE_FORWARD') %]
  /**
   * @see bi::ODEForwardFunction::dfdt
   */
  template<class T, class V1, class V2>
  static CUDA_FUNC_BOTH void dfdt(const bi::Coord& cox, const T t,
      const V1& pax, V2& dfdt);
  [% END-%]

  [%-FOREACH CheckTrait.execute(Name, 'IS_GENERIC_FORWARD') %]
  /**
   * @see bi::GenericForwardFunction::f
   */
  template<class T, class V1, class V2>
  static CUDA_FUNC_BOTH void f(const bi::Coord& cox, const T t, const V1& pax,
      const T tnxt, V2& xnxt);
  [% END-%]

  [%-FOREACH CheckTraits3.execute(Name, 'HAS_GAUSSIAN_PRIOR', 'HAS_NORMAL_PRIOR', 'HAS_LOG_NORMAL_PRIOR') %]
  /**
   * Prior mean.
   */
  static real mu0();

  /**
   * Prior standard deviation.
   */
  static real sigma0();
  [% END-%]

  [%-FOREACH CheckTraits3.execute(Name, 'IS_GAUSSIAN_LIKELIHOOD', 'IS_NORMAL_LIKELIHOOD', 'IS_LOG_NORMAL_LIKELIHOOD') %]
  /**
   * @see bi::GaussianLikelihoodMuFunction::mu
   * @see bi::LogNormalLikelihoodFunction::mu
   */
  template<class V1, class V2>
  static CUDA_FUNC_BOTH void mu(const bi::Coord& cox, const V1& pax, V2& mu);

  /**
   * @see bi::GaussianLikelihoodMuFunction::sigma
   * @see bi::LogNormalLikelihoodFunction::sigma
   */
  template<class V1, class V2>
  static CUDA_FUNC_BOTH void sigma(const bi::Coord& cox, const V1& pax,
      V2& sigma);
  [% END-%]

  [%-FOREACH CheckTrait.execute(Name, 'IS_GENERIC_STATIC') %]
  /**
   * @see bi::GenericStaticFunction::s
   */
  template<class V1, class V2>
  static CUDA_FUNC_BOTH void s(const bi::Coord& cox, const V1& pax, V2& x);
  [% END %]

};

[%# Headers-%]
#include "bi/model/model.hpp"
#include "bi/traits/type_traits.hpp"
#include "bi/traits/dimension_traits.hpp"
#include "bi/traits/boundary_traits.hpp"
[% FOREACH CheckTrait.execute(Name, 'IS_S_NODE')-%]
#include "bi/traits/static_traits.hpp"
[% END-%]
[%-FOREACH CheckTraits2.execute(Name, 'IS_D_NODE', 'IS_C_NODE')-%]
#include "bi/traits/forward_traits.hpp"
[% END-%]
[%-FOREACH CheckTraits4.execute(Name, 'IS_S_NODE', 'IS_D_NODE', 'IS_C_NODE', 'IS_P_NODE')-%]
#include "bi/traits/prior_traits.hpp"
[% END-%]
[%-FOREACH CheckTrait.execute(Name, 'IS_R_NODE')-%]
#include "bi/traits/random_traits.hpp"
[% END-%]
[%-FOREACH CheckTrait.execute(Name, 'IS_O_NODE')-%]
#include "bi/traits/likelihood_traits.hpp"
[% END-%]

[%#-Dimension declaration-%]
[% IF Node.HasX %]HAS_X([% ClassName %])[% END %]
[% IF Node.HasY %]HAS_Y([% ClassName %])[% END %]
[% IF Node.HasZ %]HAS_Z([% ClassName %])[% END %]

[%#-Trait declarations-%]
[%-FOREACH Trait = GetTraits.execute(Name)-%]
[% Trait.Name %]([% ClassName %]);
[% END-%]

[%#-Includes for other referenced nodes-%]
[%-FOREACH Type = [ 'S', 'D', 'C', 'R', 'F', 'P' ]-%]
[%-FOREACH Parent = GetDistinctParents.execute(Name, "IS_${Type}_NODE")-%]
#include "[% Parent.Name | ucfirst %]Node.hpp"
[% END %]
[% END-%]

[%#-Function definitions-%]
[%-BLOCK Parents-%]
[%-FOREACH Type = [ 'S', 'D', 'C', 'R', 'F', 'P' ]-%]
[%-FOREACH Parent = GetParents.execute(Name, "IS_${Type}_NODE")-%]
  BI_UNUSED const V2 [% INCLUDE Variable Name = Parent.Name XOffset = Parent.XOffset YOffset = Parent.YOffset ZOffset = Parent.ZOffset %] = pax.template fetch<[% Parent.Name | ucfirst %]Node,[% Parent.XOffset %],[% Parent.YOffset %],[% Parent.ZOffset %]>(cox);
[% END %]
[% END-%]
[%-END-%]

[%-BLOCK Formulae-%]
[% FOREACH Formula = GetFormulae.execute(Name, Function) %]
[% IF loop.count == 1 %]if[% ELSE %] else if[% END %] (true
[%-IF Formula.XOrdinate >= 0 %] && x == [% Formula.XOrdinate-%][%-END-%]
[%-IF Formula.YOrdinate >= 0 %] && y == [% Formula.YOrdinate-%][%-END-%]
[%-IF Formula.ZOrdinate >= 0 %] && z == [% Formula.ZOrdinate-%][%-END-%]) {
    [% Result %] = [% Formula.Formula | cudaexp %];
  }
[% END %]
[% END-%]

[%-Constants = BLOCK-%]
[%-FOREACH Constant = GetConstantParents.execute(Name)-%]
[%-IF Constant.NumFormulas == 1-%]
  BI_UNUSED const V2 [% INCLUDE Variable Name = Constant.Name XOffset = Constant.XOffset YOffset = Constant.YOffset ZOffset = Constant.ZOffset %] = [% Constant.Formula | cudaexp %];
[% ELSE-%]
  BI_UNUSED V2 [% INCLUDE Variable Name = Constant.Name XOffset = Constant.XOffset YOffset = Constant.YOffset ZOffset = Constant.ZOffset %];
  [% INCLUDE Formulae Name = Constant.Name Function = 'x' Result = Constant.Name %]
[% END-%]
[%-END-%]
[%-END-%]

[%-Inlines = BLOCK-%]
[%-FOREACH Inline = GetInlineParents.execute(Name)-%]
[%-IF Inline.NumFormulas == 1-%]
  BI_UNUSED const V2 [% INCLUDE Variable Name = Inline.Name XOffset = Inline.XOffset YOffset = Inline.YOffset ZOffset = Inline.ZOffset %] = [% Inline.Formula | cudaexp %];
[% ELSE-%]
  BI_UNUSED V2 [% INCLUDE Variable Name = Inline.Name XOffset = Inline.XOffset YOffset = Inline.YOffset ZOffset = Inline.ZOffset %];
[% INCLUDE Formulae Name = Inline.Name Function = 'x' Result = Inline.Name %]
[% END-%]
[%-END-%]
[%-END-%]

[%-Parents = INCLUDE Parents-%]

[%-FOREACH CheckTrait.execute(Name, 'IS_ODE_FORWARD')-%]
template<class T1, class V1, class V2>
inline void [% ClassName %]::dfdt(const bi::Coord& cox, const T1 t,
    const V1& pax, V2& dfdt) {
  [%-Parents-%]
  [%-Constants-%]
  [%-Inlines-%]

  [% INCLUDE Formulae Function = 'dfdt' Result = 'dfdt' %]
}
[%-END-%]

[%-FOREACH CheckTrait.execute(Name, 'IS_GENERIC_FORWARD')-%]
template<class T1, class V1, class V2>
inline void [% ClassName %]::f(const bi::Coord& cox, const T1 t, const V1& pax,
    const T1 tnxt, V2& xnxt) {
  [%-Parents-%]
  [%-Constants-%]
  [%-Inlines-%]

  [% INCLUDE Formulae Function = 'f' Result = 'xnxt' %]
}
[%-END %]

[% FOREACH CheckTraits3.execute(Name, 'HAS_GAUSSIAN_PRIOR', 'HAS_NORMAL_PRIOR', 'HAS_LOG_NORMAL_PRIOR')-%]
inline real [% ClassName %]::mu0() {
  real result;
  [% INCLUDE Formulae Function = 'mu0' Result = 'result' %]

  return result;
}

inline real [% ClassName %]::sigma0() {
  real result;
  [% INCLUDE Formulae Function = 'sigma0' Result = 'result' %]

  return result;
}
[%-END %]

[% FOREACH CheckTraits3.execute(Name, 'IS_GAUSSIAN_LIKELIHOOD', 'IS_NORMAL_LIKELIHOOD', 'IS_LOG_NORMAL_LIKELIHOOD')-%]
template<class V1, class V2>
inline void [% ClassName %]::mu(const bi::Coord& cox, const V1& pax, V2& mu) {
  [% Parents %]
  [% Constants %]
  [% Inlines %]

  [% INCLUDE Formulae Function = 'mu' Result = 'mu' %]
}

template<class V1, class V2>
inline void [% ClassName %]::sigma(const bi::Coord& cox, const V1& pax,
    V2& sigma) {
  [% Parents %]
  [% Constants %]
  [% Inlines %]

  [% INCLUDE Formulae Function = 'sigma' Result = 'sigma' %]
}
[%-END %]

[%-FOREACH CheckTrait.execute(Name, 'IS_GENERIC_STATIC')-%]
template<class V1, class V2>
inline void [% ClassName %]::s(const bi::Coord& cox, const V1& pax, V2& x) {
  [% Parents %]
  [% Constants %]
  [% Inlines %]

  [% INCLUDE Formulae Function = 's' Result = 'x' %]
}
[%-END %]

#endif
