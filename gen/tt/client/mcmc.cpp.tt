/**
 * @file
 *
 * @author Lawrence Murray <lawrence.murray@csiro.au>
 * $Rev$
 * $Date$
 */
#include "device.hpp"
#include "distros.hpp"
#include "model/[% ClassName %].hpp"

#include "bi/cuda/cuda.hpp"
#include "bi/math/ode.hpp"
#include "bi/state/State.hpp"
#include "bi/random/Random.hpp"
#include "bi/method/ParticleMCMC.hpp"
#include "bi/method/ParticleFilter.hpp"
#include "bi/method/AuxiliaryParticleFilter.hpp"
#include "bi/method/StratifiedResampler.hpp"
#include "bi/buffer/ParticleMCMCNetCDFBuffer.hpp"
#include "bi/buffer/SparseInputNetCDFBuffer.hpp"
#include "bi/buffer/ParticleFilterNetCDFBuffer.hpp"
#include "bi/buffer/AuxiliaryParticleFilterNetCDFBuffer.hpp"

#include "boost/typeof/typeof.hpp"

#include <iostream>
#include <iomanip>
#include <string>
#include <getopt.h>

#ifdef USE_CPU
#define LOCATION ON_HOST
#else
#define LOCATION ON_DEVICE
#endif

using namespace bi;

int main(int argc, char* argv[]) {
  /* model type */
  typedef [% ClassName %]<X_LEN,Y_LEN,Z_LEN> model_type;
  
  /* command line arguments */
  enum {
    ID_ARG,
    DELTA_ARG,
    ATOLER_ARG,
    RTOLER_ARG,
    S1_ARG,
    S2_ARG,
    BETA_ARG,
    ADAPT_ARG,
    LAMBDA0_ARG,
    GAMMA_ARG,
    ESS_REL_ARG,
    INIT_NS_ARG,
    FORCE_NS_ARG,
    OBS_NS_ARG,
    SEED_ARG,
    INIT_FILE_ARG,
    FORCE_FILE_ARG,
    OBS_FILE_ARG,
    OUTPUT_FILE_ARG,
    FILTER_FILE_ARG,
    FILTER_ARG,
    RESAMPLER_ARG,
    SORT_ARG,
    PROPOSAL_TYPE_ARG,
    STARTING_TYPE_ARG,
    PROPOSAL_FILE_ARG,
    STARTING_FILE_ARG,
    INCLUDE_INITIAL_ARG
  };
  real T = 0.0, DELTA = 1.0, H = 1.0, RTOLER = 1.0e-3, ATOLER = 1.0e-3,
      S1 = 0.0, S2 = 0.0, BETA = 1.0e-3, ESS_REL = 1.0, LAMBDA0 = 1000.0,
      GAMMA = 1.0e-2;
  int ID = 0, P = 1024, INIT_NS = 0, FORCE_NS = 0, OBS_NS = 0,
      SEED = 0, C = 100, A = 1000;
  std::string INIT_FILE, FORCE_FILE, OBS_FILE, FILTER_FILE, OUTPUT_FILE,
      PROPOSAL_FILE, STARTING_FILE;
  std::string PROPOSAL_TYPE("prior"), STARTING_TYPE("prior"),
      RESAMPLER("stratified"), FILTER("bootstrap");
  bool INCLUDE_INITIAL = true, ADAPT = true, SORT = true;
  int c, option_index;

  option long_options[] = {
      {"id", required_argument, 0, ID_ARG },
      {"delta", required_argument, 0, DELTA_ARG },
      {"atoler", required_argument, 0, ATOLER_ARG },
      {"rtoler", required_argument, 0, RTOLER_ARG },
      {"s1", required_argument, 0, S1_ARG },
      {"s2", required_argument, 0, S2_ARG },
      {"beta", required_argument, 0, BETA_ARG },
      {"adapt", required_argument, 0, ADAPT_ARG },
      {"lambda0", required_argument, 0, LAMBDA0_ARG },
      {"gamma", required_argument, 0, GAMMA_ARG },
      {"ess-rel", required_argument, 0, ESS_REL_ARG },
      {"init-ns", required_argument, 0, INIT_NS_ARG },
      {"force-ns", required_argument, 0, FORCE_NS_ARG },
      {"obs-ns", required_argument, 0, OBS_NS_ARG },
      {"seed", required_argument, 0, SEED_ARG },
      {"init-file", optional_argument, 0, INIT_FILE_ARG },
      {"force-file", required_argument, 0, FORCE_FILE_ARG },
      {"obs-file", required_argument, 0, OBS_FILE_ARG },
      {"filter-file", required_argument, 0, FILTER_FILE_ARG },
      {"proposal-file", optional_argument, 0, PROPOSAL_FILE_ARG },
      {"starting-file", optional_argument, 0, STARTING_FILE_ARG },
      {"output-file", required_argument, 0, OUTPUT_FILE_ARG },
      {"proposal-type", required_argument, 0, PROPOSAL_TYPE_ARG },
      {"starting-type", required_argument, 0, STARTING_TYPE_ARG },
      {"resampler", required_argument, 0, RESAMPLER_ARG },
      {"filter", required_argument, 0, FILTER_ARG },
      {"sort", required_argument, 0, SORT_ARG },
      {"include-initial", required_argument, 0, INCLUDE_INITIAL_ARG },
      {0, 0, 0, 0}
  };
  const char* short_options = "T:h:P:C:a:";

  do {
    c = getopt_long(argc, argv, short_options, long_options, &option_index);
    if (optarg) {
      switch (c) {
      case ID_ARG:
        ID = atoi(optarg);
        break;
      case DELTA_ARG:
        DELTA = atof(optarg);
        break;
      case ATOLER_ARG:
        ATOLER = atof(optarg);
        break;
      case RTOLER_ARG:
        RTOLER = atof(optarg);
        break;
      case S1_ARG:
        S1 = atof(optarg);
        break;
      case S2_ARG:
        S2 = atof(optarg);
        break;
      case BETA_ARG:
        BETA = atof(optarg);
        break;
      case ADAPT_ARG:
        ADAPT = atoi(optarg);
        break;
      case LAMBDA0_ARG:
        LAMBDA0 = atof(optarg);
        break;
      case GAMMA_ARG:
        GAMMA = atof(optarg);
        break;
      case ESS_REL_ARG:
        ESS_REL = atof(optarg);
        break;
      case INIT_NS_ARG:
        INIT_NS = atoi(optarg);
        break;
      case FORCE_NS_ARG:
        FORCE_NS = atoi(optarg);
        break;
      case OBS_NS_ARG:
        OBS_NS = atoi(optarg);
        break;
      case SEED_ARG:
        SEED = atoi(optarg);
        break;
      case INIT_FILE_ARG:
        INIT_FILE = std::string(optarg);
        break;
      case FORCE_FILE_ARG:
        FORCE_FILE = std::string(optarg);
        break;
      case OBS_FILE_ARG:
        OBS_FILE = std::string(optarg);
        break;
      case OUTPUT_FILE_ARG:
        OUTPUT_FILE = std::string(optarg);
        break;
      case FILTER_FILE_ARG:
        FILTER_FILE = std::string(optarg);
        break;
      case PROPOSAL_FILE_ARG:
        PROPOSAL_FILE = std::string(optarg);
        break;
      case STARTING_FILE_ARG:
        STARTING_FILE = std::string(optarg);
        break;
      case PROPOSAL_TYPE_ARG:
        PROPOSAL_TYPE = std::string(optarg);
        break;
      case STARTING_TYPE_ARG:
        STARTING_TYPE = std::string(optarg);
        break;
      case RESAMPLER_ARG:
        RESAMPLER = std::string(optarg);
        break;
      case FILTER_ARG:
        FILTER = std::string(optarg);
        break;
      case SORT_ARG:
        SORT = atoi(optarg);
        break;
      case INCLUDE_INITIAL_ARG:
        INCLUDE_INITIAL = atoi(optarg);
        break;
      case 'T':
        T = atof(optarg);
        break;
      case 'h':
        H = atof(optarg);
        break;
      case 'P':
        P = atoi(optarg);
        break;
      case 'C':
        C = atoi(optarg);
        break;
      case 'a':
        A = atoi(optarg);
        break;
      }
    }
  } while (c != -1);

  /* bi init */
  #ifdef __CUDACC__
  chooseDevice(ID);
  cudaThreadSetCacheConfig(cudaFuncCachePreferL1);
  #endif
  bi_omp_init();
  bi_ode_init(H, ATOLER, RTOLER);

  /* NetCDF error reporting */
  NcError ncErr(NcError::silent_nonfatal);

  /* random number generator */
  Random rng(SEED);

  /* model */
  model_type m;
  const int NP = m.getNetSize(P_NODE);
  const int ND = m.getNetSize(D_NODE);
  const int NC = m.getNetSize(C_NODE);
  const int N = (INCLUDE_INITIAL) ? ND + NC + NP : NP;
  
  /* scaling factors */
  if (S1 <= 0.0) {
    S1 = std::pow(2.4,2)/N;
  }
  if (S2 <= 0.0) {
    S2 = std::pow(2.4,2)/N;
  }

  /* state and intermediate results */
  Static<LOCATION> theta(m);
  State<LOCATION> s(m, P);
  host_vector<real> x(N); // initial state of chain
  P = s.size(); // may change according to implementation

  /* initialise from prior */
  m.getPrior<D_NODE>().samples(rng, s.get(D_NODE));
  m.getPrior<C_NODE>().samples(rng, s.get(C_NODE));
  m.getPrior<P_NODE>().samples(rng, theta.get(P_NODE));      
  
  /* inputs */
  SparseInputNetCDFBuffer *inForce = NULL, *inInit = NULL;
  if (!FORCE_FILE.empty()) {
    inForce = new SparseInputNetCDFBuffer(m, FORCE_FILE, FORCE_NS);
  }
  if (!INIT_FILE.empty()) {
    inInit = new SparseInputNetCDFBuffer(m, INIT_FILE, INIT_NS);
    inInit->read0(P_NODE, theta.get(P_NODE));
    inInit->read0(D_NODE, s.get(D_NODE));
    inInit->read0(C_NODE, s.get(C_NODE));
    if (INCLUDE_INITIAL) {
      subrange(x, 0, ND) = row(s.get(D_NODE), 0);
      subrange(x, ND, NC) = row(s.get(C_NODE), 0);
      subrange(x, ND + NC, NP) = row(theta.get(P_NODE), 0);
    } else {
      x = row(theta.get(P_NODE), 0);
    }
  }
  SparseInputNetCDFBuffer inObs(m, OBS_FILE, OBS_NS);
  const int Y = inObs.countUniqueTimes(T);
  
  /* output */
  ParticleMCMCNetCDFBuffer out(m, C, Y, OUTPUT_FILE, NetCDFBuffer::REPLACE);

  /* sampler */
  BOOST_AUTO(mcmc, ParticleMCMCFactory<LOCATION>::create(m, rng, &out,
      INCLUDE_INITIAL ? INITIAL_CONDITIONED : INITIAL_SAMPLED));
  
  /* prior */
  BOOST_AUTO(p0, mcmc->getPrior());

  /* proposal */
  BOOST_AUTO(q, init_proposal(m, PROPOSAL_TYPE, PROPOSAL_FILE, S2, INCLUDE_INITIAL));

  /* initialisation */
  int attempts = 0;
  do {
    BI_ERROR(attempts < 1000, "Could not initialise within bounds of prior within 1000 attempts");
    sample_starting(m, STARTING_TYPE, STARTING_FILE, S2, INCLUDE_INITIAL, rng, x);
    ++attempts;
  } while (!(p0(x) > 0.0));

  /* resampler */
  StratifiedResampler resam(rng, SORT);
  
  /* sample */
  if (FILTER.compare("auxiliary") == 0) {
    AuxiliaryParticleFilterNetCDFBuffer outFilter(m, P, Y, FILTER_FILE,
        NetCDFBuffer::REPLACE);
    BOOST_AUTO(filter, AuxiliaryParticleFilterFactory<LOCATION>::create(m, rng, DELTA,
        inForce, &inObs, &outFilter));
    if (ADAPT) {
      mcmc->sample(q, x, C, T, theta, s, filter, &resam, ESS_REL, LAMBDA0, GAMMA, BETA, A, S1);
    } else {
      mcmc->sample(q, x, C, T, theta, s, filter, &resam, ESS_REL, LAMBDA0, GAMMA);    
    }
    delete filter;
  } else {
    ParticleFilterNetCDFBuffer outFilter(m, P, Y, FILTER_FILE,
        NetCDFBuffer::REPLACE);
    BOOST_AUTO(filter, ParticleFilterFactory<LOCATION>::create(m, rng, DELTA,
        inForce, &inObs, &outFilter));
    if (ADAPT) {
      mcmc->sample(q, x, C, T, theta, s, filter, &resam, ESS_REL, LAMBDA0, GAMMA, BETA, A, S1);
    } else {
      mcmc->sample(q, x, C, T, theta, s, filter, &resam, ESS_REL, LAMBDA0, GAMMA);    
    }
    delete filter;
  }
  
  /* wrap up */
  std::cout << mcmc->getNumAccepted() << " of " << mcmc->getNumSteps() <<
      " proposals accepted" << std::endl;

  delete mcmc;
  delete inForce;
  delete inInit;

  return 0;
}
