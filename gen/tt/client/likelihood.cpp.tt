/**
 * @file
 *
 * @author Lawrence Murray <lawrence.murray@csiro.au>
 * $Rev$
 * $Date$
 */
#include "device.hpp"
#include "distros.hpp"
#include "model/[% ClassName %].hpp"

#include "bi/cuda/cuda.hpp"
#include "bi/math/ode.hpp"
#include "bi/state/State.hpp"
#include "bi/random/Random.hpp"
#include "bi/pdf/AdditiveExpGaussianPdf.hpp"
#include "bi/pdf/ExpGaussianMixturePdf.hpp"
#include "bi/method/ParticleMCMC.hpp"
#include "bi/method/ParticleFilter.hpp"
#include "bi/method/ConditionalUnscentedParticleFilter.hpp"
#include "bi/method/MarginalUnscentedParticleFilter.hpp"
#include "bi/method/AuxiliaryParticleFilter.hpp"
#include "bi/method/AuxiliaryConditionalUnscentedParticleFilter.hpp"
#include "bi/method/AuxiliaryMarginalUnscentedParticleFilter.hpp"
#include "bi/method/StratifiedResampler.hpp"
#include "bi/buffer/SparseInputNetCDFBuffer.hpp"
#include "bi/buffer/ParticleMCMCNetCDFBuffer.hpp"
#include "bi/buffer/ParticleFilterNetCDFBuffer.hpp"
#include "bi/buffer/AuxiliaryParticleFilterNetCDFBuffer.hpp"

#include "boost/typeof/typeof.hpp"

#include <iostream>
#include <iomanip>
#include <string>
#include <getopt.h>

#ifdef USE_CPU
#define LOCATION ON_HOST
#else
#define LOCATION ON_DEVICE
#endif

using namespace bi;

/**
 * Command line arguments structure.
 */
struct Args {  
  real T, DELTA, H, RTOLER, ATOLER, S2, ESS_REL;
  int ID, P, INIT_NS, FORCE_NS, OBS_NS, SEED, C, M;
  std::string INIT_FILE, FORCE_FILE, OBS_FILE, FILTER_FILE, OUTPUT_FILE,
      STARTING_FILE, STARTING_TYPE, RESAMPLER, FILTER;
  bool INCLUDE_INITIAL, SORT;
  
  /**
   * Constructor
   */
  Args() {
    T = 0.0;
    DELTA = 1.0;
    H = 1.0;
    RTOLER = 1.0e-3;
    ATOLER = 1.0e-3;
    S2 = 0.0;
    ESS_REL = 1.0;
    ID = 0;
    P = 1024;
    INIT_NS = 0;
    FORCE_NS = 0;
    OBS_NS = 0;
    SEED = 0;
    C = 1000;
    M = 10;
    STARTING_TYPE = std::string("prior");
    RESAMPLER = std::string("stratified");
    FILTER = std::string("pf");
    INCLUDE_INITIAL = true;
    SORT = true;    
  }
};

/**
 * Main.
 * 
 * @param argc Number of arguments.
 * @param argv Arguments
 */
int main(int argc, char* argv[]);

/**
 * Perform sampling routine.
 * 
 * @tparam Factory Factory type for creating filter.
 * 
 * @param args Command line arguments.
 */
template<class Factory>
void run(Args& args);

/**
 * Read command line arguments.
 * 
 * @param argc Number of arguments.
 * @param argv Arguments
 * 
 * @return Struct of command line arguments.
 */
Args read_args(int argc, char* argv[]);

int main(int argc, char* argv[]) {
  /* command line arguments */
  Args args(read_args(argc, argv));
  
  /* run */
  if (args.FILTER.find("pf") == 0) {
    run<ParticleFilterFactory<LOCATION> >(args);
  } else if (args.FILTER.find("apf") == 0) {
    run<AuxiliaryParticleFilterFactory<LOCATION> >(args);
  } else if (args.FILTER.find("mupf") == 0) {
    run<MarginalUnscentedParticleFilterFactory<LOCATION> >(args);
  } else if (args.FILTER.find("amupf") == 0) {
    run<AuxiliaryMarginalUnscentedParticleFilterFactory<LOCATION> >(args);
  } else if (args.FILTER.find("cupf") == 0) {
    run<ConditionalUnscentedParticleFilterFactory<LOCATION> >(args);
  } else if (args.FILTER.find("acupf") == 0) {
    run<AuxiliaryConditionalUnscentedParticleFilterFactory<LOCATION> >(args);
  } else {
    std::cerr << "Filter type " << args.FILTER << " unrecognised" <<
        std::endl;
    exit(1);
  }
  
  return 0;
}

template<class Factory>
void run(Args& args) {
  /* init */
  #ifdef __CUDACC__
  int dev = chooseDevice(ID);
  std::cerr << "Using device " << dev << std::endl;
  cudaThreadSetCacheConfig(cudaFuncCachePreferL1);
  #endif
  bi_omp_init();
  bi_ode_init(args.H, args.ATOLER, args.RTOLER);
  NcError ncErr(NcError::silent_nonfatal);

  /* model */
  typedef [% ClassName %]<X_LEN,Y_LEN,Z_LEN> model_type;
  model_type m;
  const int ND = m.getNetSize(D_NODE);
  const int NC = m.getNetSize(C_NODE);
  const int NP = m.getNetSize(P_NODE);
  const int N = (args.INCLUDE_INITIAL) ? ND + NC + NP : NP;

  /* random number generator */
  Random rng(args.SEED);

  /* scaling factors */
  if (args.S2 <= 0.0) {
    args.S2 = std::pow(2.4,2)/N;
  }

  /* state and intermediate results */
  Static<LOCATION> theta(m);
  State<LOCATION> s(m, args.P);
  args.P = s.size();

  /* sample all points, ensures consistent set of points regardless of
   * different random number requirements between methods */
  host_matrix<real> X((args.C + args.M - 1)/args.M, N);
  sample_starting(m, args.STARTING_TYPE, args.STARTING_FILE, args.S2,
      args.INCLUDE_INITIAL, rng, X);

  /* inputs */
  SparseInputNetCDFBuffer *inForce = NULL, *inInit = NULL;
  if (!args.FORCE_FILE.empty()) {
    inForce = new SparseInputNetCDFBuffer(m, args.FORCE_FILE, args.FORCE_NS);
  }
  if (!args.INIT_FILE.empty()) {
    inInit = new SparseInputNetCDFBuffer(m, args.INIT_FILE, args.INIT_NS);
    inInit->read0(P_NODE, theta.get(P_NODE));
    inInit->read0(D_NODE, s.get(D_NODE));
    inInit->read0(C_NODE, s.get(C_NODE));
    if (args.INCLUDE_INITIAL) {
      subrange(row(X, 0), 0, ND) = row(s.get(D_NODE), 0);
      subrange(row(X, 0), ND, NC) = row(s.get(C_NODE), 0);
      subrange(row(X, 0), ND + NC, NP) = row(theta.get(P_NODE), 0);
    } else {
      row(X, 0) = row(theta.get(P_NODE), 0);
    }
  }
  SparseInputNetCDFBuffer inObs(m, args.OBS_FILE, args.OBS_NS);
  const int Y = inObs.countUniqueTimes(args.T);
  
  /* outputs */
  ParticleMCMCNetCDFBuffer out(m, args.C, Y, args.OUTPUT_FILE,
      NetCDFBuffer::REPLACE);
  AuxiliaryParticleFilterNetCDFBuffer outFilter(m, args.P, Y,
      args.FILTER_FILE, NetCDFBuffer::REPLACE);

  /* filter */
  StratifiedResampler resam(rng, args.SORT);
  BOOST_AUTO(filter, Factory::create(m, rng, args.DELTA, inForce, &inObs,
      &outFilter));

  /* sampler */
  BOOST_AUTO(mcmc, ParticleMCMCFactory<LOCATION>::create(m, rng, &out,
      args.INCLUDE_INITIAL ? INITIAL_CONDITIONED : INITIAL_SAMPLED));
  
  /* prior */
  BOOST_AUTO(p0, mcmc->getPrior());
    
  /* compute likelhoods */
  int c;
  mcmc->init(row(X, 0), args.T, theta, s, filter, &resam);
  mcmc->output0(filter);
  for (c = 0; c < args.C; ++c) {
    mcmc->proposal(row(X, c/args.M));
    mcmc->prior();
    mcmc->likelihood(args.T, theta, s, filter, &resam, args.ESS_REL);
    mcmc->accept(filter);
    mcmc->output(c);
    mcmc->report(c);
  }
  mcmc->term(theta);
    
  delete mcmc;
  delete filter;
  delete inForce;
  delete inInit;
}

Args read_args(int argc, char* argv[]) {
  Args args;

  /* command line arguments */
  enum {
    ID_ARG,
    DELTA_ARG,
    ATOLER_ARG,
    RTOLER_ARG,
    S2_ARG,
    ESS_REL_ARG,
    INIT_NS_ARG,
    FORCE_NS_ARG,
    OBS_NS_ARG,
    SEED_ARG,
    INIT_FILE_ARG,
    FORCE_FILE_ARG,
    OBS_FILE_ARG,
    OUTPUT_FILE_ARG,
    FILTER_FILE_ARG,
    RESAMPLER_ARG,
    FILTER_ARG,
    SORT_ARG,
    STARTING_TYPE_ARG,
    STARTING_FILE_ARG,
    INCLUDE_INITIAL_ARG
  };
  
  int c, option_index;
  option long_options[] = {
      {"id", required_argument, 0, ID_ARG },
      {"delta", required_argument, 0, DELTA_ARG },
      {"atoler", required_argument, 0, ATOLER_ARG },
      {"rtoler", required_argument, 0, RTOLER_ARG },
      {"s2", required_argument, 0, S2_ARG },
      {"ess-rel", required_argument, 0, ESS_REL_ARG },
      {"init-ns", required_argument, 0, INIT_NS_ARG },
      {"force-ns", required_argument, 0, FORCE_NS_ARG },
      {"obs-ns", required_argument, 0, OBS_NS_ARG },
      {"seed", required_argument, 0, SEED_ARG },
      {"init-file", optional_argument, 0, INIT_FILE_ARG },
      {"force-file", required_argument, 0, FORCE_FILE_ARG },
      {"obs-file", required_argument, 0, OBS_FILE_ARG },
      {"filter-file", required_argument, 0, FILTER_FILE_ARG },
      {"starting-file", optional_argument, 0, STARTING_FILE_ARG },
      {"output-file", required_argument, 0, OUTPUT_FILE_ARG },
      {"starting-type", required_argument, 0, STARTING_TYPE_ARG },
      {"resampler", required_argument, 0, RESAMPLER_ARG },
      {"filter", required_argument, 0, FILTER_ARG },
      {"sort", required_argument, 0, SORT_ARG },
      {"include-initial", required_argument, 0, INCLUDE_INITIAL_ARG },
      {0, 0, 0, 0}
  };
  const char* short_options = "T:h:P:C:M:";

  do {
    c = getopt_long(argc, argv, short_options, long_options, &option_index);
    if (optarg) {
      switch (c) {
      case ID_ARG:
        args.ID = atoi(optarg);
        break;
      case DELTA_ARG:
        args.DELTA = atof(optarg);
        break;
      case ATOLER_ARG:
        args.ATOLER = atof(optarg);
        break;
      case RTOLER_ARG:
        args.RTOLER = atof(optarg);
        break;
      case S2_ARG:
        args.S2 = atof(optarg);
        break;
      case ESS_REL_ARG:
        args.ESS_REL = atof(optarg);
        break;
      case INIT_NS_ARG:
        args.INIT_NS = atoi(optarg);
        break;
      case FORCE_NS_ARG:
        args.FORCE_NS = atoi(optarg);
        break;
      case OBS_NS_ARG:
        args.OBS_NS = atoi(optarg);
        break;
      case SEED_ARG:
        args.SEED = atoi(optarg);
        break;
      case INIT_FILE_ARG:
        args.INIT_FILE = std::string(optarg);
        break;
      case FORCE_FILE_ARG:
        args.FORCE_FILE = std::string(optarg);
        break;
      case OBS_FILE_ARG:
        args.OBS_FILE = std::string(optarg);
        break;
      case OUTPUT_FILE_ARG:
        args.OUTPUT_FILE = std::string(optarg);
        break;
      case FILTER_FILE_ARG:
        args.FILTER_FILE = std::string(optarg);
        break;
      case STARTING_FILE_ARG:
        args.STARTING_FILE = std::string(optarg);
        break;
      case STARTING_TYPE_ARG:
        args.STARTING_TYPE = std::string(optarg);
        break;
      case RESAMPLER_ARG:
        args.RESAMPLER = std::string(optarg);
        break;
      case FILTER_ARG:
        args.FILTER = std::string(optarg);
        break;
      case SORT_ARG:
        args.SORT = atoi(optarg);
        break;
      case INCLUDE_INITIAL_ARG:
        args.INCLUDE_INITIAL = atoi(optarg);
        break;
      case 'T':
        args.T = atof(optarg);
        break;
      case 'h':
        args.H = atof(optarg);
        break;
      case 'P':
        args.P = atoi(optarg);
        break;
      case 'C':
        args.C = atoi(optarg);
        break;
      case 'M':
        args.M = atoi(optarg);
        break;
      }
    }
  } while (c != -1);
  
  return args;
}
