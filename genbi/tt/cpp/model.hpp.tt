[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
## $Rev$
## $Date$
%]

[%-class_name = "Model" _ model.get_name-%]
/**
 * @file
 *
 * @author Generated by genbi
 * $Rev$
 * $Date$
 */
#ifndef GENBI_[% class_name | upper %]_HPP
#define GENBI_[% class_name | upper %]_HPP

[% FOREACH dim IN model.get_dims-%]
#include "dim/Dim[% dim.get_name %].hpp"
[% END-%]

[% FOREACH var IN model.get_vars-%]
#include "var/Var[% var.get_name %].hpp"
[% END-%]

#include "bi/model/Model.hpp"
#include "bi/state/State.hpp"
#include "bi/random/Random.hpp"
#include "bi/typelist/macro_typelist.hpp"
#include "bi/typelist/macro_typetree.hpp"
#include "bi/buffer/Mask.hpp"

[%
# mapping of verbose types to abbreviations
TYPES = {
  'state' => 'd',
  'state_aux_' => 'dx',
  'input' => 'f',
  'noise' => 'r',
  'obs' => 'o',
  'param' => 'p',
  'param_aux_' => 'px'
};

# top-level dynamic blocks
DYNAMIC_BLOCKS = ['transition', 'lookahead_transition'];

# top-level static/instant blocks
STATIC_BLOCKS = ['parameter', 'parameter_post_', 'initial', 'observation', 'proposal_parameter', 'proposal_initial'];

# top-evel sparse blocks
SPARSE_BLOCKS = ['observation', 'lookahead_observation'];

# mappings for missing blocks
MAP_BLOCKS = {
  'lookahead_transition' => 'transition',
  'proposal_parameter' => 'parameter',
  'proposal_initial' => 'initial',
  'lookahead_observation' => 'observation'
};
%]

/**
 * Type list for dimensions.
 */
BEGIN_TYPELIST([% class_name %]DimTypeList)
[% FOREACH dim IN model.get_dims-%]
SINGLE_TYPE(1, Dim[% dim.get_name %])
[% END-%]
END_TYPELIST()

[%-FOREACH type IN TYPES.keys %]
/**
 * Type list for [% type %] variables.
 */
BEGIN_TYPETREE([% class_name %][% TYPES.$type | upper %]TypeList)
[% model.get_vars(type).to_typetree %]
END_TYPETREE()
[% END %]

/**
 * Model [% model.get_name %].
 */
class [% class_name %] : public bi::Model {
public:
  /**
   * Type list for dimensions.
   */
  typedef GET_TYPELIST([% class_name %]DimTypeList) DimTypeList;

  [%-FOREACH type IN TYPES.keys %]
  /**
   * Type list for [% type %] variables.
   */
  typedef GET_TYPETREE([% class_name %][% TYPES.$type | upper %]TypeList) [% TYPES.$type | upper %]TypeList;
  [% END-%]

  [%-FOREACH dim IN model.get_dims %]
  /**
   * Size of [% dim.get_name %] dimension.
   */
  static const int N[% dim.get_name | upper %] = [% dim.get_size %];
  [% END-%]
  
  /**
   * Constructor.
   */
  [% class_name %]();

  [% IF model.is_block('transition') %]
  /**
   * Get discrete time step of transition model.
   *
   * @return Time step.
   */
  static real getDelta();
  [% END %]
  
  [% IF model.is_named_arg('std_start_') && model.is_named_arg('std_size_') %]
  /**
   * Get starting index of square-root covariance variables.
   *
   * @return Starting index.
   */
  static int getStdStart();

  /**
   * Get size of square-root covariance variables.
   *
   * @return Size.
   */
  static int getStdSize();
  [% END %]

  [%-FOREACH toplevel IN DYNAMIC_BLOCKS %]
  template<class T1, bi::Location L>
  static void [% toplevel | to_camel_case %]Simulate(const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s);
  
  template<class T1, bi::Location L>
  static void [% toplevel | to_camel_case %]Samples(bi::Random& rng, const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s);

  template<class T1, bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]LogDensities(const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s, V1 p);
  [% END %]
  
  [%-FOREACH toplevel IN STATIC_BLOCKS %]
  template<bi::Location L>
  static void [% toplevel | to_camel_case %]Simulate(bi::State<[% class_name %],L>& s);

  template<bi::Location L>
  static void [% toplevel | to_camel_case %]Samples(bi::Random& rng, bi::State<[% class_name %],L>& s);
  
  template<bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]LogDensities(bi::State<[% class_name %],L>& s, V1 p);
  [% END-%]

  [%-FOREACH toplevel IN SPARSE_BLOCKS %]
  template<bi::Location L>
  static void [% toplevel | to_camel_case %]Simulate(bi::State<[% class_name %],L>& s, const bi::Mask<L>& mask);

  template<bi::Location L>
  static void [% toplevel | to_camel_case %]Samples(bi::Random& rng, bi::State<[% class_name %],L>& s, const bi::Mask<L>& mask);
  
  template<bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]LogDensities(bi::State<[% class_name %],L>& s, const bi::Mask<L>& mask, V1 p);
  [% END-%]
   
private:
  [% IF model.is_block('transition') %]
  /**
   * Is current time on the delta of the transition model?
   *
   * @param t1 Current time.
   * @param t2 Next time.
   *
   * @return True if @p t1 is on the delta of the transition model.
   */
  template<class T1>
  static bool onDelta(const T1 t1, const T1 t2);
  [% END %]

  /*
   * Dimensions
   */
  [%-FOREACH dim IN model.get_dims %]
  Dim[% dim.get_name %] dim[% dim.get_name %];
  [%-END %]

  /*
   * Variables
   */
  [%-FOREACH var IN model.get_vars %]
  Var[% var.get_name %] var[% var.get_name %];
  [%-END %]
};

[% FOREACH block IN model.get_blocks-%]
#include "block/Block[% block.get_id %].hpp"
[% END-%]

#include "bi/method/misc.hpp"

[% IF model.is_block('transition') %]
inline real [% class_name %]::getDelta() {
  return Block[% model.get_block('transition').get_id %]::getDelta();
}
[% END %]

[% IF model.is_named_arg('std_start_') && model.is_named_arg('std_size_') %]
inline int [% class_name %]::getStdStart() {
  return [% model.get_named_arg('std_start_').eval_const %];
}

inline int [% class_name %]::getStdSize() {
  return [% model.get_named_arg('std_size_').eval_const %];
}
[% END %]

[%-FOREACH toplevel IN DYNAMIC_BLOCKS %]
template<class T1, bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Simulate(const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s) {
  [%-IF model.is_block(toplevel) && model.get_block(toplevel).can_simulate %]
  Block[% model.get_block(toplevel).get_id %]::simulate(t1, t2, onDelta(t1, t2), s);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]Simulate(t1, t2, s);
  [% ELSE %]
  BI_ERROR(false, "Attempt to deterministically simulate stochastic model");
  [%-END %]
}

template<class T1, bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Samples(bi::Random& rng, const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s) {
  [%-IF model.is_block(toplevel)-%]
  Block[% model.get_block(toplevel).get_id %]::samples(rng, t1, t2, onDelta(t1, t2), s);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]Samples(rng, t1, t2, s);
  [% ELSE %]
  //
  [%-END %]
}

template<class T1, bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]LogDensities(const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s, V1 p) {
  [%-IF model.is_block(toplevel)-%]
  Block[% model.get_block(toplevel).get_id %]::logDensities(t1, t2, onDelta(t1, t2), s, p);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]LogDensities(t1, t2, s, p);
  [% ELSE %]
  //
  [%-END %]
}
[% END %]

[%-FOREACH toplevel IN STATIC_BLOCKS %]
template<bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Simulate(bi::State<[% class_name %],L>& s) {
  [%-IF model.is_block(toplevel) && model.get_block(toplevel).can_simulate %]
  Block[% model.get_block(toplevel).get_id %]::simulate(s);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]Simulate(s);
  [% ELSE %]
  BI_ERROR(false, "Attempt to deterministically simulate stochastic model");
  [%-END %]
}

template<bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Samples(bi::Random& rng, bi::State<[% class_name %],L>& s) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::samples(rng, s);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]Samples(rng, s);
  [% ELSE %]
  //
  [%-END %]
}

template<bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]LogDensities(bi::State<[% class_name %],L>& s, V1 p) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::logDensities(s, p);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]LogDensities(s, p);
  [% ELSE %]
  //
  [%-END %]
}
[% END %]

[%-FOREACH toplevel IN SPARSE_BLOCKS %]
template<bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Simulate(bi::State<[% class_name %],L>& s,
    const bi::Mask<L>& mask) {
  [%-IF model.is_block(toplevel) && model.get_block(toplevel).can_simulate %]
  Block[% model.get_block(toplevel).get_id %]::simulate(s, mask);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]Simulate(s, mask);
  [% ELSE %]
  BI_ERROR(false, "Attempt to deterministically simulate stochastic model");
  [%-END %]
}

template<bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Samples(bi::Random& rng, bi::State<[% class_name %],L>& s,
    const bi::Mask<L>& mask) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::samples(rng, s, mask);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]Samples(rng, s, mask);
  [% ELSE %]
  //
  [%-END %]
}

template<bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]LogDensities(bi::State<[% class_name %],L>& s,
    const bi::Mask<L>& mask, V1 p) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::logDensities(s, mask, p);
  [% ELSIF MAP_BLOCKS.exists(toplevel) %]
  [% MAP_BLOCKS.${toplevel} | to_camel_case %]LogDensities(s, mask, p);
  [% ELSE %]
  //
  [%-END %]
}
[% END %]

[% IF model.is_block('transition') %]
template<class T1>
inline bool [% class_name %]::onDelta(const T1 t1, const T1 t2) {
  T1 sgn = (t2 >= t1) ? 1.0 : -1.0;
  T1 nextDelta = sgn*ge_step(t1, sgn*getDelta());
  return sgn*t1 >= sgn*nextDelta;
}
[% END %]

#endif
