/**
 * @file
 *
 * @author Lawrence Murray <lawrence.murray@csiro.au>
 * $Rev$
 * $Date$
 */
#include "bi/pdf/AdditiveExpGaussianPdf.hpp"
#include "bi/pdf/ExpGaussianPdf.hpp"
#include "bi/random/Random.hpp"

#include <string>

#include "boost/typeof/typeof.hpp"

/**
 * Initialise proposal distribution.
 */
template<class B>
bi::AdditiveExpGaussianPdf<> init_proposal(B& m,
    const std::string& type, const std::string& file, const real sd,
    const bool includeInitial);

/**
 * Initialise starting distribution.
 */
template<class B>
bi::ExpGaussianPdf<> init_starting(B& m,
    const std::string& type, const std::string& file, const real sd,
    const bool includeInitial);

/**
 * Sample from starting distribution.
 */
template<class B, class M1>
void sample_starting(B& m, const std::string& type,
    const std::string& file, const real sd, const bool includeInitial,
    bi::Random& rng, M1 X);

/**
 * Initialise distribution.
 */
template<class B>
bi::ExpGaussianPdf<> init_distro(B& m, const std::string& type,
    const std::string& file, const real sd, const bool includeInitial);

/**
 * Sample from distribution.
 */
template<class B, class M1>
void sample_distro(B& m, const std::string& type,
    const std::string& file, const real sd, const bool includeInitial,
    bi::Random& rng, M1 X);

#include "bi/buffer/UnscentedKalmanFilterNetCDFBuffer.hpp"
#include "bi/buffer/UnscentedRTSSmootherNetCDFBuffer.hpp"
#include "bi/buffer/ParticleFilterNetCDFBuffer.hpp"
#include "bi/buffer/ParticleSmootherNetCDFBuffer.hpp"
#include "bi/buffer/PdfNetCDFBuffer.hpp"
#include "bi/math/host_vector.hpp"
#include "bi/math/host_matrix.hpp"
#include "bi/math/view.hpp"
#include "bi/model/model.hpp"

template<class B>
bi::AdditiveExpGaussianPdf<> init_proposal(B& m,
    const std::string& type, const std::string& file, const real sd,
    const bool includeInitial) {
  using namespace bi;
  
  ExpGaussianPdf<> q0(init_distro(m, type, file, sd, includeInitial));
  AdditiveExpGaussianPdf<> q(q0.cov(), q0.getLogs());
  
  return q;
}

template<class B>
bi::ExpGaussianPdf<> init_starting(B& m,
    const std::string& type, const std::string& file, const real sd,
    const bool includeInitial) {
  return init_distro(m, type, file, sd, includeInitial);  
}

template<class B, class M1>
void sample_starting(B& m, const std::string& type,
    const std::string& file, const real sd, const bool includeInitial,
    bi::Random& rng, M1 X) {
  if (!type.compare("file") == 0) {
    sample_distro(m, type, file, sd, includeInitial, rng, X);
  }
}

template<class B>
bi::ExpGaussianPdf<> init_distro(B& m, const std::string& type,
    const std::string& file, const real sd, const bool includeInitial) { 
  using namespace bi;
  
  const int ND = m.getNetSize(D_NODE);
  const int NC = m.getNetSize(C_NODE);
  const int NR = m.getNetSize(R_NODE);
  const int NP = m.getNetSize(P_NODE);

  /* distribution */
  ExpGaussianPdf<> q((includeInitial) ? ND + NC + NP : NP);

  /* log-variables */
  if (includeInitial) {
    q.addLogs(m.getLogs(D_NODE), 0);
    q.addLogs(m.getLogs(C_NODE), ND);
    q.addLogs(m.getLogs(P_NODE), ND + NC);
  } else {
    q.addLogs(m.getLogs(P_NODE));
  }

  /* initialise with prior mean and covariance */
  host_vector<real> mu(ND + NC + NR + NP);
  host_matrix<real> Sigma(ND + NC + NR + NP, ND + NC + NR + NP);

  mu.clear();
  ident(Sigma);
  
  mean(m.template getPrior<D_NODE>(), subrange(mu, 0, ND));
  mean(m.template getPrior<C_NODE>(), subrange(mu, ND, NC));
  mean(m.template getPrior<P_NODE>(), subrange(mu, ND + NC + NR, NP));
  
  cov(m.template getPrior<D_NODE>(), subrange(Sigma, 0, ND, 0, ND));
  cov(m.template getPrior<C_NODE>(), subrange(Sigma, ND, NC, ND, NC));
  cov(m.template getPrior<P_NODE>(), subrange(Sigma, ND + NC + NR, NP,
      ND + NC + NR, NP));
  
  /* overwrite covariance according to proposal type */
  if (type.compare("file") == 0) {
    host_vector<real> mu1(ND + NC + NP);
    host_matrix<real> Sigma1(ND + NC + NP, ND + NC + NP);

    PdfNetCDFBuffer in(file, NetCDFBuffer::READ_ONLY);
    in.readPdf(mu1, Sigma1);

    subrange(mu, 0, ND + NC) = subrange(mu1, 0, ND + NC);
    subrange(Sigma, 0, ND + NC, 0, ND + NC) = subrange(Sigma1, 0, ND + NC, 0,
        ND + NC);
    subrange(mu, ND + NC + NR, NP) = subrange(mu1, ND + NC, NP);
    subrange(Sigma, ND + NC + NR, NP, ND + NC + NR, NP) = subrange(Sigma1,
        ND + NC, NP, ND + NC, NP);
  } else if (type.compare("ukf") == 0) {
    host_vector<real> mu1(mu.size());
    host_matrix<real> Sigma1(Sigma.size1(), Sigma.size2());
    
    UnscentedKalmanFilterNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
        STATIC_OWN);
    in.readCorrectedState(in.size2() - 1, mu1, Sigma1);
    
    subrange(mu, ND + NC + NR, NP) = subrange(mu1, ND + NC + NR, NP);
    subrange(Sigma, ND + NC + NR, NP, ND + NC + NR, NP) = subrange(Sigma1,
        ND + NC + NR, NP, ND + NC + NR, NP);
  } else if (type.compare("urts") == 0) {
    UnscentedRTSSmootherNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
        STATIC_OWN);
    in.readSmoothState(0, mu, Sigma);
  } else if (type.compare("pf") == 0) {
    ParticleFilterNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
        STATIC_OWN);

    host_matrix<real> X(in.size1(), NP);
    host_vector<real> w(in.size1());

    in.readState(P_NODE, in.size2() - 1, X);
    log_columns(X, m.getLogs(P_NODE));

    in.readLogWeights(in.size2() - 1, w);    
    element_exp_unnormalised(w.begin(), w.end(), w.begin());
    
    mean(X, w, subrange(mu, ND + NC + NR, NP));
    cov(X, w, subrange(mu, ND + NC + NR, NP), subrange(Sigma, ND + NC + NR,
        NP, ND + NC + NR, NP));
  } else if (type.compare("pfs") == 0) {
    ParticleSmootherNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
        STATIC_OWN);
    
    host_matrix<real> X(in.size1(), NP);
    host_vector<real> w(in.size1());
    
    in.readState(P_NODE, in.size2() - 1, X);
    log_columns(X, m.getLogs(P_NODE));
    
    in.readLogWeights(in.size2() - 1, w);    
    element_exp_unnormalised(w.begin(), w.end(), w.begin());
    
    mean(X, w, subrange(mu, ND + NC + NR, NP));
    cov(X, w, subrange(mu, ND + NC + NR, NP), subrange(Sigma, ND + NC + NR,
        NP, ND + NC + NR, NP));
  } else if (type.compare("kfb") == 0) {
    ParticleSmootherNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
        STATIC_OWN);
    
    host_matrix<real> X(in.size1(), ND + NC + NR + NP);
    host_vector<real> w(in.size1());
    
    in.readState(D_NODE, 0, columns(X, 0, ND));
    in.readState(C_NODE, 0, columns(X, ND, NC));
    in.readState(R_NODE, 0, columns(X, ND + NC, NR));
    in.readState(P_NODE, 0, columns(X, ND + NC + NR, NP));
    
    log_columns(columns(X, 0, ND), m.getLogs(D_NODE));
    log_columns(columns(X, ND, NC), m.getLogs(C_NODE));
    log_columns(columns(X, ND + NC, NR), m.getLogs(R_NODE));
    log_columns(columns(X, ND + NC + NR, NP), m.getLogs(P_NODE));
    
    in.readLogWeights(0, w);    
    element_exp_unnormalised(w.begin(), w.end(), w.begin());
    
    mean(X, w, mu);
    cov(X, w, mu, Sigma);    
  } else {
    BI_ERROR(type.compare("prior") == 0, "Unrecognised proposal type");
  }
  
  /* project down to required components */
  if (includeInitial) {
    subrange(q.mean(), 0, ND + NC) = subrange(mu, 0, ND + NC);
    subrange(q.mean(), ND + NC, NP) = subrange(mu, ND + NC + NR, NP);
    
    subrange(q.cov(), 0, ND + NC, 0, ND + NC) = subrange(Sigma, 0, ND + NC,
        0, ND + NC);
    subrange(q.cov(), ND + NC, NP, ND + NC, NP) = subrange(Sigma,
        ND + NC + NR, NP, ND + NC + NR, NP);
    subrange(q.cov(), 0, ND + NC, ND + NC, NP) = subrange(Sigma, 0, ND + NC,
        ND + NC + NR, NP);
  } else {
    q.mean() = subrange(mu, ND + NC + NR, NP);
    q.cov() = subrange(Sigma, ND + NC + NR, NP, ND + NC + NR, NP);
  }
  
  /* scale */
  matrix_scal(sd, q.cov());
  
  q.init();
  
  return q;
}

template<class B, class M1>
void sample_distro(B& m, const std::string& type,
    const std::string& file, const real sd, const bool includeInitial,
    bi::Random& rng, M1 X) { 
  using namespace bi;
  
  const int ND = m.getNetSize(D_NODE);
  const int NC = m.getNetSize(C_NODE);
  const int NR = m.getNetSize(R_NODE);
  const int NP = m.getNetSize(P_NODE);
  
  /* initialise with sample from prior */
  if (includeInitial) {
    m.template getPrior<D_NODE>().samples(rng, columns(X, 0, ND));
    m.template getPrior<C_NODE>().samples(rng, columns(X, ND, NC));
    m.template getPrior<P_NODE>().samples(rng, columns(X, ND + NC, NP));
  } else {
    m.template getPrior<P_NODE>().samples(rng, X);    
  }
  
  if (type.compare("ukf") == 0 || type.compare("urts") == 0 || type.compare("file") == 0) {
    /* distribution */
    ExpGaussianPdf<> q((includeInitial) ? ND + NC + NP : NP);
  
    /* log-variables */
    if (includeInitial) {
      q.addLogs(m.getLogs(D_NODE), 0);
      q.addLogs(m.getLogs(C_NODE), ND);
      q.addLogs(m.getLogs(P_NODE), ND + NC);
    } else {
      q.addLogs(m.getLogs(P_NODE));
    }
  
    /* initialise with prior mean and covariance */
    host_vector<real> mu(ND + NC + NR + NP);
    host_matrix<real> Sigma(ND + NC + NR + NP, ND + NC + NR + NP);
  
    mu.clear();
    ident(Sigma);
    
    mean(m.template getPrior<D_NODE>(), subrange(mu, 0, ND));
    mean(m.template getPrior<C_NODE>(), subrange(mu, ND, NC));
    mean(m.template getPrior<P_NODE>(), subrange(mu, ND + NC + NR, NP));
    
    cov(m.template getPrior<D_NODE>(), subrange(Sigma, 0, ND, 0, ND));
    cov(m.template getPrior<C_NODE>(), subrange(Sigma, ND, NC, ND, NC));
    cov(m.template getPrior<P_NODE>(), subrange(Sigma, ND + NC + NR, NP,
        ND + NC + NR, NP));
    
    /* overwrite covariance according to proposal type */
    if (type.compare("ukf") == 0) {
      host_vector<real> mu1(mu.size());
      host_matrix<real> Sigma1(Sigma.size1(), Sigma.size2());
      
      UnscentedKalmanFilterNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
          STATIC_OWN);
      in.readCorrectedState(in.size2() - 1, mu1, Sigma1);
      
      subrange(mu, ND + NC + NR, NP) = subrange(mu1, ND + NC + NR, NP);
      subrange(Sigma, ND + NC + NR, NP, ND + NC + NR, NP) = subrange(Sigma1,
          ND + NC + NR, NP, ND + NC + NR, NP);
    } else if (type.compare("urts") == 0) {
      UnscentedRTSSmootherNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
          STATIC_OWN);
      in.readSmoothState(0, mu, Sigma);
    } else if (type.compare("file") == 0) {
      host_vector<real> mu1(ND + NC + NP);
      host_matrix<real> Sigma1(ND + NC + NP, ND + NC + NP);

      PdfNetCDFBuffer in(file, NetCDFBuffer::READ_ONLY);
      in.readPdf(mu1, Sigma1);

      subrange(mu, 0, ND + NC) = subrange(mu1, 0, ND + NC);
      subrange(Sigma, 0, ND + NC, 0, ND + NC) = subrange(Sigma1, 0, ND + NC, 0,
          ND + NC);
      subrange(mu, ND + NC + NR, NP) = subrange(mu1, ND + NC, NP);
      subrange(Sigma, ND + NC + NR, NP, ND + NC + NR, NP) = subrange(Sigma1,
          ND + NC, NP, ND + NC, NP);
    }
    
    /* project down to required components */
    if (includeInitial) {
      subrange(q.mean(), 0, ND + NC) = subrange(mu, 0, ND + NC);
      subrange(q.mean(), ND + NC, NP) = subrange(mu, ND + NC + NR, NP);
      
      subrange(q.cov(), 0, ND + NC, 0, ND + NC) = subrange(Sigma, 0, ND + NC,
          0, ND + NC);
      subrange(q.cov(), ND + NC, NP, ND + NC, NP) = subrange(Sigma,
          ND + NC + NR, NP, ND + NC + NR, NP);
      subrange(q.cov(), 0, ND + NC, ND + NC, NP) = subrange(Sigma, 0,
          ND + NC, ND + NC + NR, NP);
    } else {
      q.mean() = subrange(mu, ND + NC + NR, NP);
      q.cov() = subrange(Sigma, ND + NC + NR, NP, ND + NC + NR, NP);
    }
    
    /* scale */
    matrix_scal(sd, q.cov());
    
    q.init();
    q.samples(rng, X);
  } else if (type.compare("pf") == 0) {
    ParticleFilterNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
        STATIC_OWN);    

    host_vector<real> w(in.size1());
    in.readLogWeights(in.size2() - 1, w);    
    element_exp_unnormalised(w.begin(), w.end(), w.begin());
    
    for (int i = 0; i < X.size1(); ++i) {
      int p = rng.multinomial(w);
      if (includeInitial) {
        in.readSingle(P_NODE, p, in.size2() - 1, subrange(row(X, i),
            ND + NC, NP));
      } else {
        in.readSingle(P_NODE, p, in.size2() - 1, row(X, i));
      }
    }
  } else if (type.compare("kfb") == 0  || type.compare("pfs") == 0) {
    ParticleSmootherNetCDFBuffer in(m, file, NetCDFBuffer::READ_ONLY,
        STATIC_OWN);
    
    host_vector<real> w(in.size1());
    in.readLogWeights(0, w);    
    element_exp_unnormalised(w.begin(), w.end(), w.begin());
    
    for (int i = 0; i < X.size1(); ++i) {
      int p = rng.multinomial(w);
      if (includeInitial) {
        in.readSingle(D_NODE, p, 0, subrange(row(X, i), 0, ND));
        in.readSingle(C_NODE, p, 0, subrange(row(X, i), ND, NC));
        in.readSingle(P_NODE, p, in.size2() - 1, subrange(row(X, i), ND + NC,
            NP));
      } else {
        in.readSingle(P_NODE, p, in.size2() - 1, row(X, i));
      }
    }
  } else {
    BI_ERROR(type.compare("prior") == 0, "Unrecognised proposal type");
  }
}
