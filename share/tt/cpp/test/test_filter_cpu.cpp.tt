[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
%]

[%-PROCESS client/misc/header.cpp.tt-%]
[%-PROCESS macro.hpp.tt-%]

#include "model/[% class_name %].hpp"

#include "bi/kd/kde.hpp"
#include "bi/state/ThetaState.hpp"
#include "bi/random/Random.hpp"
#include "bi/method/ParticleMarginalMetropolisHastings.hpp"

[% IF client.get_named_arg('filter') == 'kalman' %]
#include "bi/method/ExtendedKalmanFilter.hpp"
#include "bi/cache/KalmanFilterCache.hpp"
[% ELSE %]
[% IF client.get_named_arg('filter') == 'lookahead' %]
#include "bi/method/AuxiliaryParticleFilter.hpp"
[% ELSIF client.get_named_arg('filter') == 'bridge' %]
#include "bi/method/BridgeParticleFilter.hpp"
[% ELSIF client.get_named_arg('filter') == 'adaptive' %]
#include "bi/method/AdaptiveParticleFilter.hpp"
#include "bi/cache/AdaptiveParticleFilterCache.hpp"
#include "bi/stopper/Stopper.hpp"
#include "bi/stopper/SumOfWeightsStopper.hpp"
#include "bi/stopper/MinimumESSStopper.hpp"
#include "bi/stopper/StdDevStopper.hpp"
#include "bi/stopper/VarStopper.hpp"
[% ELSE %]
#include "bi/method/ParticleFilter.hpp"
[% END %]
#include "bi/cache/ParticleFilterCache.hpp"
#include "bi/resampler/MultinomialResampler.hpp"
#include "bi/resampler/MetropolisResampler.hpp"
#include "bi/resampler/RejectionResampler.hpp"
#include "bi/resampler/KernelResampler.hpp"
#include "bi/resampler/StratifiedResampler.hpp"
#include "bi/resampler/SystematicResampler.hpp"
[% END %]

#include "bi/method/Simulator.hpp"
#include "bi/method/Forcer.hpp"
#include "bi/method/Observer.hpp"
#include "bi/buffer/SparseInputNetCDFBuffer.hpp"
#include "bi/ode/IntegratorConstants.hpp"
#include "bi/misc/TicToc.hpp"

#include "boost/typeof/typeof.hpp"

#include <iostream>
#include <iomanip>
#include <string>
#include <getopt.h>

#ifdef ENABLE_CUDA
#define LOCATION ON_DEVICE
#else
#define LOCATION ON_HOST
#endif

int main(int argc, char* argv[]) {
  using namespace bi;

  /* model type */
  typedef [% class_name %] model_type;
  
  /* command line arguments */
  [% read_argv(client) %]
  
  /* MPI init */
  #ifdef ENABLE_MPI
  boost::mpi::environment env(argc, argv);
  #endif
  
  /* bi init */
  bi_init(NTHREADS);

  /* random number generator */
  Random rng(SEED);

  /* model */
  model_type m;

  /* inputs */
  SparseInputNetCDFBuffer *bufInput = NULL, *bufInit = NULL, *bufObs = NULL;
  if (!INPUT_FILE.empty()) {
    bufInput = new SparseInputNetCDFBuffer(m, INPUT_FILE, INPUT_NS, INPUT_NP);
  }
  if (!INIT_FILE.empty()) {
    bufInit = new SparseInputNetCDFBuffer(m, INIT_FILE, INIT_NS, INIT_NP);
  }
  if (!OBS_FILE.empty()) {
    bufObs = new SparseInputNetCDFBuffer(m, OBS_FILE, OBS_NS, OBS_NP);
  }
  
  /* schedule */
  Schedule sched(m, START_TIME, END_TIME, NOUTPUTS, bufInput, bufObs);

  /* state and intermediate results */
  [% IF client.get_named_arg('filter') == 'kalman' %]
  NPARTICLES = 1;
  [% END %]
  ThetaState<model_type,LOCATION> s(NPARTICLES, sched.numOutputs());
  NPARTICLES = s.size(); // may change according to implementation
  
  /* simulator */
  BOOST_AUTO(in, bi::ForcerFactory<LOCATION>::create(bufInput));
  BOOST_AUTO(obs, ObserverFactory<LOCATION>::create(bufObs));
  BOOST_AUTO(sim, bi::SimulatorFactory::create(m, in, obs));

  /* filter */
  [% IF client.get_named_arg('filter') == 'kalman' %]
    BOOST_AUTO(outFilter, bi::KalmanFilterCacheFactory<LOCATION>::create());
    BOOST_AUTO(filter, (ExtendedKalmanFilterFactory::create(m, sim, outFilter)));
  [% ELSE %]
    [% IF client.get_named_arg('filter') == 'adaptive' %]
    BOOST_AUTO(outFilter, AdaptiveParticleFilterCacheFactory<LOCATION>::create());
    [% ELSE %]
    BOOST_AUTO(outFilter, ParticleFilterCacheFactory<LOCATION>::create());
    [% END %]

    /* resampler */
    [% IF client.get_named_arg('resampler') == 'kernel' %]
    real h;
    if (B_ABS > 0.0) {
      h = B_ABS;
    } else {
      h = B_REL*bi::hopt(m.getDynSize(), NPARTICLES);
    }
    MultinomialResampler base(WITH_SORT, ESS_REL);
    KernelResampler<BOOST_TYPEOF(base)> resam(&base, h, WITH_SHRINK, ESS_REL);
    [% ELSIF client.get_named_arg('resampler') == 'metropolis' %]
    MetropolisResampler resam(C, ESS_REL);
    [% ELSIF client.get_named_arg('resampler') == 'rejection' %]
    RejectionResampler resam;
    [% ELSIF client.get_named_arg('resampler') == 'multinomial' %]
    MultinomialResampler resam(WITH_SORT, ESS_REL);
    [% ELSIF client.get_named_arg('resampler') == 'systematic' %]
    SystematicResampler resam(WITH_SORT, ESS_REL);
    [% ELSE %]
    StratifiedResampler resam(WITH_SORT, ESS_REL);
    [% END %]
        
    /* particle filter */
    [% IF client.get_named_arg('filter') == 'lookahead' %]
      BOOST_AUTO(filter, (AuxiliaryParticleFilterFactory::create(m, sim, &resam, outFilter)));
    [% ELSIF client.get_named_arg('filter') == 'bridge' %]
      BOOST_AUTO(filter, (BridgeParticleFilterFactory::create(m, sim, &resam, outFilter)));
    [% ELSIF client.get_named_arg('filter') == 'adaptive' %]
      /* stopper */
      [% IF client.get_named_arg('stopper') == 'deterministic' %]
      Stopper stopper(NPARTICLES, MAX_PARTICLES, BLOCK_PARTICLES, sched.numObs());
      [% ELSIF client.get_named_arg('stopper') == 'sumofweights' %]
      SumOfWeightsStopper stopper(STOPPER_THRESHOLD, MAX_PARTICLES, BLOCK_PARTICLES, sched.numObs());
      [% ELSIF client.get_named_arg('stopper') == 'miness' %]
      MinimumESSStopper stopper(STOPPER_THRESHOLD, MAX_PARTICLES, BLOCK_PARTICLES, sched.numObs());
      [% ELSIF client.get_named_arg('stopper') == 'stddev' %]
      StdDevStopper stopper(STOPPER_THRESHOLD, MAX_PARTICLES, BLOCK_PARTICLES, sched.numObs());
      [% ELSIF client.get_named_arg('stopper') == 'var' %]
      VarStopper stopper(STOPPER_THRESHOLD, MAX_PARTICLES, BLOCK_PARTICLES, sched.numObs());
      [% END %]
      BOOST_AUTO(filter, (AdaptiveParticleFilterFactory::create(m, sim, &resam, &stopper, outFilter)));
    [% ELSE %]
      BOOST_AUTO(filter, (ParticleFilterFactory::create(m, sim, &resam, outFilter)));
    [% END %]
  [% END %]

  /* test */
  bi::host_vector<real> lls(NRUNS), ts(NRUNS);
  
  #ifdef ENABLE_GPERFTOOLS
  ProfilerStart(GPERFTOOLS_FILE.c_str());
  #endif
  #ifdef ENABLE_TIMING
  TicToc timer;
  #endif

  std::cout << std::setw(13) << "Rel. ESS";
  std::cout << std::setw(13) << "CAR";
  std::cout << std::setw(13) << "L (mean)";
  std::cout << std::setw(13) << "L (std)";
  #ifdef ENABLE_TIMING
  std::cout << std::setw(13) << "t (mean us)";
  std::cout << std::setw(13) << "t (std us)";
  #endif
  std::cout << std::setw(13) << "No. samples";
  std::cout << std::endl;

  int k;
  for (int j = 0; j < NOBS; ++j) {
    bufObs->setnp(OBS_NP + j);
    obs->clear();

    k = 0;
    for (int i = 0; i < NRUNS; ++i) {
      try {
        #ifdef ENABLE_TIMING
        synchronize();
        timer.tic();
        #endif
        lls(k) = filter->filter(rng, sched.begin(), sched.end(), s, bufInit);
        #ifdef ENABLE_TIMING
        synchronize();
        ts(k) = timer.toc();
        #endif
        ++k;
      } catch (ParticleFilterDegeneratedException e) {
        //
      }
    }
  
    BOOST_AUTO(lls1, subrange(lls, 0, k));
    BOOST_AUTO(ts1, subrange(ts, 0, k));
  
    real ress = bi::ess_reduce(lls1)/k;
    real car = bi::car_reduce(lls1);
    real llmu = bi::sum_reduce(lls1)/k;
    real llstd = bi::sqrt(k*(bi::sumsq_reduce(lls1)/k - llmu*llmu)/(k - 1));
    #ifdef ENABLE_TIMING
    real tmu = bi::sum_reduce(ts1)/k;
    real tstd = bi::sqrt(k*(bi::sumsq_reduce(ts1)/k - tmu*tmu)/(k - 1));
    #endif

    std::cout << std::setw(13) << ress;
    std::cout << std::setw(13) << car;
    std::cout << std::setw(13) << llmu;
    std::cout << std::setw(13) << llstd;
    #ifdef ENABLE_TIMING
    std::cout << std::setw(13) << tmu;
    std::cout << std::setw(13) << tstd;
    #endif
    std::cout << std::setw(13) << k;
    std::cout << std::endl;
  }

  #ifdef ENABLE_GPERFTOOLS
  ProfilerStop();
  #endif
 
  delete filter;
  delete outFilter;
  delete sim;
  delete obs;
  delete in;
  delete bufObs;
  delete bufInit;
  delete bufInput;
}
