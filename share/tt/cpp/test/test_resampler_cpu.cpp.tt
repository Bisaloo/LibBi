[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
## $Rev$
## $Date$
%]

[%-PROCESS client/misc/header.cpp.tt-%]
[%-PROCESS macro.hpp.tt-%]

#include "bi/resampler/MultinomialResampler.hpp"
#include "bi/resampler/MetropolisResampler.hpp"
#include "bi/resampler/RejectionResampler.hpp"
#include "bi/resampler/KernelResampler.hpp"
#include "bi/resampler/StratifiedResampler.hpp"
#include "bi/resampler/SystematicResampler.hpp"
#include "bi/random/Random.hpp"
#include "bi/pdf/GaussianPdf.hpp"
#include "bi/math/loc_vector.hpp"
#include "bi/math/loc_matrix.hpp"
#include "bi/misc/TicToc.hpp"
#include "bi/buffer/netcdf.hpp"

#include <iostream>
#include <string>
#include <unistd.h>
#include <getopt.h>

[% IF client.get_named_arg('with-cuda') %]
#define LOCATION ON_DEVICE
#define OTHER_LOCATION ON_HOST
[% ELSE %]
#define LOCATION ON_HOST
#define OTHER_LOCATION ON_DEVICE
[% END %]

int main(int argc, char* argv[]) {
  using namespace bi;

  /* command line arguments */
  [% read_argv(client) %]

  /* MPI init */
  #ifdef ENABLE_MPI
  boost::mpi::environment env(argc, argv);
  #endif
  
  /* bi init */
  bi_init(NTHREADS);

  /* random number generator */
  Random rng(SEED);

  /* set up output file */
  int ncid = bi::nc_create(OUTPUT_FILE, NC_NETCDF4);

  int zDim = bi::nc_def_dim(ncid, "z", ZS);
  int PDim = bi::nc_def_dim(ncid, "P", PS);
  int repDim = bi::nc_def_dim(ncid, "rep", REPS);
  
  std::vector<int> dimids(3);
  dimids[0] = zDim;
  dimids[1] = PDim;
  dimids[2] = repDim;
  
  int sseVar = bi::nc_def_var(ncid, "sse", NC_DOUBLE, dimids);
  int seVar = bi::nc_def_var(ncid, "se", NC_DOUBLE, dimids);
  int timeVar = bi::nc_def_var(ncid, "time", NC_INT, dimids);
  int PVar = bi::nc_def_var(ncid, "P", NC_INT, PDim);
  int zVar = bi::nc_def_var(ncid, "z", NC_DOUBLE, zDim);
    
  /* resampler */
  [% IF client.get_named_arg('resampler') == 'metropolis' %]
  MetropolisResampler resam(C);
  [% ELSIF client.get_named_arg('resampler') == 'rejection' %]
  RejectionResampler resam;
  [% ELSIF client.get_named_arg('resampler') == 'multinomial' %]
  MultinomialResampler resam(WITH_SORT);
  [% ELSIF client.get_named_arg('resampler') == 'systematic' %]
  SystematicResampler resam(WITH_SORT);
  [% ELSIF client.get_named_arg('resampler') == 'stratified' %]
  StratifiedResampler resam(WITH_SORT);
  [% END %]

  /* buffers for weight-sets and results */
  typedef typename loc_temp_vector<LOCATION,real>::type vector_type;
  typedef typename loc_temp_matrix<LOCATION,real>::type matrix_type;
  typedef typename loc_temp_vector<LOCATION,int>::type int_vector_type;
  typedef typename loc_temp_matrix<LOCATION,int>::type int_matrix_type;

  typedef typename loc_temp_vector<OTHER_LOCATION,real>::type vector_alt_type;
  typedef typename loc_temp_matrix<OTHER_LOCATION,real>::type matrix_alt_type;
  typedef typename loc_temp_vector<OTHER_LOCATION,int>::type int_vector_alt_type;
  typedef typename loc_temp_matrix<OTHER_LOCATION,int>::type int_matrix_alt_type;

  typedef typename loc_temp_vector<ON_HOST,double>::type err_vector_type;
  typedef typename loc_temp_vector<ON_HOST,int>::type err_int_vector_type;
  
  /* generate particles (all on host so weight sets match on host and device) */
  int maxP = std::pow(2, PS + 4);
  int actualP = 0;
  
  host_matrix<real,-1,-1,-1,1> x(maxP*REPS, 1);  // particles
  host_matrix<real,-1,-1,-1,1> lW(maxP, REPS); // log-weights
  host_matrix<int,-1,-1,-1,1> times(REPS, PS);
  host_matrix<real,-1,-1,-1,1> ses(REPS, PS), sses(REPS, PS);
  host_vector<int,-1,1> actualPs(PS);
  host_vector<real,-1,1> zs(ZS);
  
  GaussianPdf<> f(1), g(1);
  f.samples(rng, x);
  
  /* test */
  #ifdef ENABLE_GPERFTOOLS
  ProfilerStart(GPERFTOOLS_FILE.c_str());
  #endif
  TicToc timer;
  int z, p, rep, time;
  real se, sse;
  for (z = 0; z < ZS; ++z) {
    /* generate log-weights */
    if (z > 0) {
      addscal_elements(vec(x), 0.5, vec(x));
    }
    g.logDensities(x, vec(lW), true);
    zs(z) = 0.5*z;
    std::cerr << "z=" << zs(z) << ":";
  
    /* test on weight sets */
    for (p = 0; p < PS; ++p) {
      actualP = std::pow(2, p + 4);
      std::cerr << " " << actualP;
      actualPs(p) = actualP;
      
      vector_type lws(actualP);
      vector_alt_type lws_other(actualP);
      int_vector_type as(actualP);
      int_vector_alt_type as_other(actualP);
      int_vector_type os(actualP);
      int_vector_type Os(actualP);
      err_vector_type lws_err(actualP);
      err_int_vector_type os_err(actualP);

      seq_elements(as, 0); // needed for sort and ess    

      [% IF client.get_named_arg('resampler') == 'metropolis' %]
      real W = actualP*bi::exp(-0.25*zs(z)*zs(z))/(2.0*bi::sqrt(BI_PI));
      real wmax = (1.0/BI_SQRT_TWO_PI)/W;
      real beta = 1.0/actualP;
      real alpha = (1.0 - wmax)/(actualP*wmax);
      real epsilon = 1.0e-2*wmax;
      real lambda = 1.0 - alpha - beta;
      int B = (int)bi::ceil(bi::log(epsilon*(alpha + beta)/bi::max(alpha, beta))/bi::log(lambda));
      resam.setSteps(B);
      [% END %]
    
      for (rep = 0; rep < REPS; ++rep) {
        if (WITH_COPY) {
          lws_other = subrange(column(lW, rep), 0, actualP);
          synchronize();
          timer.tic();
          lws = lws_other;
          if (LOCATION == ON_HOST) {
            synchronize();
          }
        } else {
          lws = subrange(column(lW, rep), 0, actualP);
          synchronize();
          timer.tic();
        }
        
        [% IF client.get_named_arg('resampler') == 'stratified' %]
        resam.cumulativeOffspring(rng, lws, Os, actualP);
        resam.cumulativeOffspringToAncestorsPermute(Os, as);
        [% ELSIF client.get_named_arg('resampler') == 'systematic' %]
        resam.cumulativeOffspring(rng, lws, Os, actualP);
        resam.cumulativeOffspringToAncestorsPermute(Os, as);
        [% ELSIF client.get_named_arg('resampler') == 'rejection' %]
        real maxLogWeight = -BI_HALF_LOG_TWO_PI;
        resam.ancestorsPermute(rng, lws, as, maxLogWeight);
        [% ELSIF client.get_named_arg('resampler') == 'metropolis' %]
        resam.ancestorsPermute(rng, lws, as);
        [% ELSIF client.get_named_arg('resampler') == 'multinomial' %]
        resam.ancestors(rng, lws, as);
        resam.permute(as);
        [% ELSIF client.get_named_arg('resampler') == 'sort' %]
        bi::sort(lws);
        [% ELSIF client.get_named_arg('resampler') == 'ess' %]
        real ess = bi::ess_reduce(lws);
        [% END %]

        /* time */
        [% IF client.get_named_arg('resampler') != 'sort' && client.get_named_arg('resampler') != 'ess' %]
        if (WITH_COPY) {
          as_other = as;
        }
        [% END %]
        synchronize();
        time = timer.toc();

        /* errors, always computed on host in double precision for comparability */
        [% IF client.get_named_arg('resampler') != 'sort' && client.get_named_arg('resampler') != 'ess' %]
        resam.ancestorsToOffspring(as, os);
        synchronize();        
        lws_err = lws;
        os_err = os;
        synchronize();
        se = resam.se(lws_err, os_err);
        sse = resam.sse(lws_err, os_err);
        [% ELSE %]
        se = 0.0;
        sse = 0.0;
        [% END %]
        
        ses(rep, p) = se;
        sses(rep, p) = sse;
        times(rep, p) = time;
      }
    }
    
    /* output */
    std::vector<size_t> start(3), count(3);
    start[0] = z;
    start[1] = 0;
    start[2] = 0;
    count[0] = 1;
    count[1] = PS;
    count[2] = REPS;
    
    bi::nc_put_vara(ncid, seVar, start, count, ses.buf());
    bi::nc_put_vara(ncid, sseVar, start, count, sses.buf());
    bi::nc_put_vara(ncid, timeVar, start, count, times.buf());

    std::cerr << std::endl;
  }
  
  bi::nc_put_var(ncid, PVar, actualPs.buf());
  bi::nc_put_var(ncid, zVar, zs.buf());

  #ifdef ENABLE_GPERFTOOLS
  ProfilerStop();
  #endif
  
  /* clean up */
  bi::nc_close(ncid);

  return 0;
}
