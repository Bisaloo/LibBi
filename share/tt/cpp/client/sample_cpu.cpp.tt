[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
## $Rev$
## $Date$
%]

[%-PROCESS client/misc/header.cpp.tt-%]
[%-PROCESS macro.hpp.tt-%]

#include "model/[% class_name %].hpp"

#include "bi/ode/IntegratorConstants.hpp"
#include "bi/misc/TicToc.hpp"
#include "bi/kd/kde.hpp"

#include "bi/random/Random.hpp"

#include "bi/state/State.hpp"
#include "bi/state/MarginalMHState.hpp"
#include "bi/state/MarginalSIRState.hpp"
#include "bi/state/MarginalSISState.hpp"

#include "bi/method/Forcer.hpp"
#include "bi/method/Observer.hpp"
#include "bi/method/Simulator.hpp"

#include "bi/resampler/MultinomialResampler.hpp"
#include "bi/resampler/MetropolisResampler.hpp"
#include "bi/resampler/RejectionResampler.hpp"
#include "bi/resampler/KernelResampler.hpp"
#include "bi/resampler/StratifiedResampler.hpp"
#include "bi/resampler/SystematicResampler.hpp"

#include "bi/adapter/GaussianAdapter.hpp"

#include "bi/stopper/Stopper.hpp"
#include "bi/stopper/SumOfWeightsStopper.hpp"
#include "bi/stopper/MinimumESSStopper.hpp"
#include "bi/stopper/StdDevStopper.hpp"
#include "bi/stopper/VarStopper.hpp"

#include "bi/buffer/SimulatorBuffer.hpp"
#include "bi/buffer/ParticleFilterBuffer.hpp"
#include "bi/buffer/KalmanFilterBuffer.hpp"
#include "bi/buffer/MCMCBuffer.hpp"
#include "bi/buffer/SMCBuffer.hpp"
#include "bi/buffer/SRSBuffer.hpp"

#include "bi/cache/SimulatorCache.hpp"
#include "bi/cache/AdaptivePFCache.hpp"
#include "bi/cache/BootstrapPFCache.hpp"
#include "bi/cache/ExtendedKFCache.hpp"
#include "bi/cache/MCMCCache.hpp"
#include "bi/cache/SMCCache.hpp"
#include "bi/cache/SRSCache.hpp"

#include "bi/netcdf/InputNetCDFBuffer.hpp"
#include "bi/netcdf/SimulatorNetCDFBuffer.hpp"
#include "bi/netcdf/MCMCNetCDFBuffer.hpp"
#include "bi/netcdf/SMCNetCDFBuffer.hpp"

#include "bi/null/InputNullBuffer.hpp"
#include "bi/null/SimulatorNullBuffer.hpp"
#include "bi/null/MCMCNullBuffer.hpp"
#include "bi/null/SMCNullBuffer.hpp"

#include "bi/method/FilterFactory.hpp"
#include "bi/method/SamplerFactory.hpp"

#ifdef ENABLE_MPI
#include "bi/mpi/resampler/DistributedResampler.hpp"
#include "bi/mpi/adapter/DistributedAdapter.hpp"
#include "bi/mpi/stopper/DistributedStopper.hpp"
#include "bi/mpi/TreeNetworkNode.hpp"
#include "bi/mpi/Server.hpp"
#include "bi/mpi/Client.hpp"
#endif

#include "boost/typeof/typeof.hpp"

#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
#include <getopt.h>

#ifdef ENABLE_CUDA
#define LOCATION ON_DEVICE
#else
#define LOCATION ON_HOST
#endif

int main(int argc, char* argv[]) {
  using namespace bi;

  /* model type */
  typedef [% class_name %] model_type;
  
  /* command line arguments */
  [% read_argv(client) %]
  
  /* MPI init */
  #ifdef ENABLE_MPI
  boost::mpi::environment env(argc, argv);
  boost::mpi::communicator world;
  const int rank = world.rank();
  const int size = world.size();
  NPARTICLES /= size;
  #else
  const int rank = 0;
  const int size = 1;
  #endif
    
  /* bi init */
  bi_init(NTHREADS);
  
  /* MPI */
  #ifdef ENABLE_MPI
  TreeNetworkNode node;
  #endif

  /* random number generator */
  Random rng(SEED);

  /* model */
  model_type m;

  /* input file */
  [% IF client.get_named_arg('input-file') != '' %]
  InputNetCDFBuffer bufInput(m, INPUT_FILE, INPUT_NS, INPUT_NP);
  [% ELSE %]
  InputNullBuffer bufInput(m);
  [% END %]
  
  /* init file */
  [% IF client.get_named_arg('init-file') != '' %]
  InputNetCDFBuffer bufInit(m, INIT_FILE, INIT_NS, INIT_NP);
  [% ELSE %]
  InputNullBuffer bufInit(m);
  [% END %]

  /* obs file */
  [% IF client.get_named_arg('obs-file') != '' %]
  InputNetCDFBuffer bufObs(m, OBS_FILE, OBS_NS, OBS_NP);
  [% ELSE %]
  InputNullBuffer bufObs(m);
  [% END %]

  /* schedule */
  Schedule sched(m, START_TIME, END_TIME, NOUTPUTS, NBRIDGES, bufInput, bufObs, WITH_OUTPUT_AT_OBS);

  /* numbers of particles */
  NPARTICLES = bi::roundup(NPARTICLES);
  MAX_PARTICLES = bi::roundup(MAX_PARTICLES);
  BLOCK_PARTICLES = bi::roundup(BLOCK_PARTICLES);

  /* output */
  [% IF client.get_named_arg('target') == 'posterior' %]
    [% IF client.get_named_arg('sampler') == 'sir' %]
      [% IF client.get_named_arg('output-file') != '' %]
      typedef SMCNetCDFBuffer buffer_type;
      [% ELSE %]
      typedef SMCNullBuffer buffer_type;
      [% END %]
      SMCBuffer<SMCCache<LOCATION,buffer_type> > out(m, NSAMPLES, sched.numOutputs(), OUTPUT_FILE, REPLACE, MULTI);
    [% ELSIF client.get_named_arg('sampler') == 'sis' %]
      [% IF client.get_named_arg('output-file') != '' %]
      typedef SMCNetCDFBuffer buffer_type;
      [% ELSE %]
      typedef SMCNullBuffer buffer_type;
      [% END %]
      SRSBuffer<SRSCache<LOCATION,buffer_type> > out(m, NSAMPLES, sched.numOutputs(), OUTPUT_FILE, REPLACE, MULTI);
    [% ELSE %]
      [% IF client.get_named_arg('output-file') != '' %]
      typedef MCMCNetCDFBuffer buffer_type;
      [% ELSE %]
      typedef MCMCNullBuffer buffer_type;
      [% END %]
      MCMCBuffer<MCMCCache<LOCATION,buffer_type> > out(m, NSAMPLES, sched.numOutputs(), OUTPUT_FILE, REPLACE, MULTI);
    [% END %]
  [% ELSE %]
    [% IF client.get_named_arg('output-file') != '' %]
    typedef SimulatorNetCDFBuffer buffer_type;
    [% ELSE %]
    typedef SimulatorNullBuffer buffer_type;
    [% END %]
    SimulatorBuffer<SimulatorCache<LOCATION,buffer_type> > out(m, NSAMPLES, sched.numOutputs(), OUTPUT_FILE, REPLACE, MULTI);
  [% END %]
  
  /* resampler for x-particles */
  [% IF client.get_named_arg('resampler') == 'metropolis' %]
  MetropolisResampler filterResam(C, ESS_REL, BRIDGE_ESS_REL);
  [% ELSIF client.get_named_arg('resampler') == 'rejection' %]
  RejectionResampler filterResam;
  [% ELSIF client.get_named_arg('resampler') == 'multinomial' %]
  MultinomialResampler filterResam(WITH_SORT, ESS_REL, BRIDGE_ESS_REL);
  [% ELSIF client.get_named_arg('resampler') == 'stratified' %]
  StratifiedResampler filterResam(WITH_SORT, ESS_REL, BRIDGE_ESS_REL);
  [% ELSE %]
  SystematicResampler filterResam(WITH_SORT, ESS_REL, BRIDGE_ESS_REL);
  [% END %]
  
  /* stopper for x-particles */
  [% IF client.get_named_arg('stopper') == 'deterministic' %]
  Stopper filterStopper(NPARTICLES, STOPPER_MAX, sched.numObs());
  [% ELSIF client.get_named_arg('stopper') == 'sumofweights' %]
  SumOfWeightsStopper filterStopper(STOPPER_THRESHOLD, STOPPER_MAX, sched.numObs());
  [% ELSIF client.get_named_arg('stopper') == 'miness' %]
  MinimumESSStopper filterStopper(STOPPER_THRESHOLD, STOPPER_MAX, sched.numObs());
  [% ELSIF client.get_named_arg('stopper') == 'stddev' %]
  StdDevStopper filterStopper(STOPPER_THRESHOLD, STOPPER_MAX, sched.numObs());
  [% ELSIF client.get_named_arg('stopper') == 'var' %]
  VarStopper filterStopper(STOPPER_THRESHOLD, STOPPER_MAX, sched.numObs());
  [% END %]
 
  /* resampler for theta-particles */
  [% IF client.get_named_arg('sample-resampler') == 'metropolis' %]
  MetropolisResampler sampleResamBase(C, SAMPLE_ESS_REL, BRIDGE_ESS_REL);
  [% ELSIF client.get_named_arg('sample-resampler') == 'rejection' %]
  RejectionResampler sampleResamBase;
  [% ELSIF client.get_named_arg('sample-resampler') == 'multinomial' %]
  MultinomialResampler sampleResamBase(WITH_SORT, SAMPLE_ESS_REL, BRIDGE_ESS_REL);
  [% ELSIF client.get_named_arg('sample-resampler') == 'stratified' %]
  StratifiedResampler sampleResamBase(WITH_SORT, SAMPLE_ESS_REL, BRIDGE_ESS_REL);
  [% ELSE %]
  SystematicResampler sampleResamBase(WITH_SORT, SAMPLE_ESS_REL, BRIDGE_ESS_REL);
  [% END %]
  [% IF client.get_named_arg('with-mpi') %]
  DistributedResampler<BOOST_TYPEOF(sampleResamBase)> sampleResam(sampleResamBase, SAMPLE_ESS_REL, BRIDGE_ESS_REL);
  [% ELSE %]
  BOOST_AUTO(sampleResam&, sampleResamBase);
  [% END %]
  
  /* stopper for theta-particles */
  [% IF client.get_named_arg('sample-stopper') == 'deterministic' %]
  Stopper sampleStopperBase(NPARTICLES, STOPPER_MAX, sched.numObs());
  [% ELSIF client.get_named_arg('sample-stopper') == 'sumofweights' %]
  SumOfWeightsStopper sampleStopperBase(STOPPER_THRESHOLD, STOPPER_MAX, sched.numObs());
  [% ELSIF client.get_named_arg('sample-stopper') == 'miness' %]
  MinimumESSStopper sampleStopperBase(STOPPER_THRESHOLD, STOPPER_MAX, sched.numObs());
  [% ELSIF client.get_named_arg('sample-stopper') == 'stddev' %]
  StdDevStopper sampleStopperBase(STOPPER_THRESHOLD, STOPPER_MAX, sched.numObs());
  [% ELSIF client.get_named_arg('sample-stopper') == 'var' %]
  VarStopper sampleStopperBase(STOPPER_THRESHOLD, STOPPER_MAX, sched.numObs());
  [% END %]
  [% IF client.get_named_arg('with-mpi') %]
  DistributedStopper<BOOST_TYPEOF(sampleStopperBase)> sampleStopper(sampleStopperBase, node);
  [% ELSE %]
  BOOST_AUTO(sampleStopper&, sampleStopperBase);
  [% END %]
  
  /* adapter for theta-particles */ 
  GaussianAdapter<model_type,LOCATION> sampleAdapterBase;
  [% IF client.get_named_arg('with-mpi') %]
  DistributedAdapter<BOOST_TYPEOF(sampleAdapterBase)> sampleAdapter(sampleAdapterBase, node);
  [% ELSE %]
  BOOST_AUTO(sampleAdapter&, sampleAdapterBase);
  [% END %]
  
  /* client/server setup */
  #ifdef ENABLE_MPI
  Client client(node);
  Server server(node);
  MarginalSISHandler<model_type,BOOST_TYPEOF(sampleAdapter),BOOST_TYPEOF(sampleStopper)> handler(m, sched.numObs(), adapter, stopper, node);
  std::string port_name;
  
  if (ROLE.compare("server") == 0) {
  	server.open();
  	std::ofstream bufServer(SERVER_FILE.c_str());
  	bufServer << server.getPortName();
  	bufServer.close();
  	server.run(handler);
  	server.close();
  	exit(0);
  } else {
    std::ifstream bufServer(SERVER_FILE.c_str());
    bufServer >> port_name;
    bufServer.close();
    //client.connect(port_name.c_str());
  }
  #endif
  
  /* state */
  [% IF client.get_named_arg('target') == 'posterior' %]
    [% IF client.get_named_arg('filter') == 'kalman' %]
    NPARTICLES = 1;
    typedef ExtendedKFState<model_type,LOCATION> state_type;
    typedef KalmanFilterBuffer<ExtendedKFCache<LOCATION> > cache_type;
    [% ELSIF client.get_named_arg('filter') == 'lookahead' || client.get_named_arg('filter') == 'bridge' %]
    typedef AuxiliaryPFState<model_type,LOCATION> state_type;
    typedef ParticleFilterBuffer<BootstrapPFCache<LOCATION> > cache_type;
    [% ELSIF client.get_named_arg('filter') == 'adaptive' %]
    typedef BootstrapPFState<model_type,LOCATION> state_type;
    typedef ParticleFilterBuffer<AdaptivePFCache<LOCATION> > cache_type;
    [% ELSE %]
    typedef BootstrapPFState<model_type,LOCATION> state_type;
    typedef ParticleFilterBuffer<BootstrapPFCache<LOCATION> > cache_type;
    [% END %]
    [% IF client.get_named_arg('sampler') == 'sir' %]
    MarginalSIRState<model_type,LOCATION,state_type,cache_type> s(m, NSAMPLES, NPARTICLES, sched.numOutputs());
    [% ELSIF client.get_named_arg('sampler') == 'sis' %]
    typedef GaussianPdf<> proposal_type;
    MarginalSISState<model_type,LOCATION,state_type,cache_type,proposal_type> s(m, NPARTICLES, sched.numOutputs());
    [% ELSE %]
    MarginalMHState<model_type,LOCATION,state_type,cache_type> s(m, NPARTICLES, sched.numOutputs());
    [% END %]
  [% ELSE %]
  State<model_type,LOCATION> s(NSAMPLES);
  [% END %]

  /* simulator */
  BOOST_AUTO(in, ForcerFactory<LOCATION>::create(bufInput));
  BOOST_AUTO(obs, ObserverFactory<LOCATION>::create(bufObs));
  BOOST_AUTO(sim, SimulatorFactory::create(m, *in, *obs));

  /* filter */
  [% IF client.get_named_arg('filter') == 'kalman' %]
  BOOST_AUTO(filter, (FilterFactory::createExtendedKF(m, *sim)));
  [% ELSIF client.get_named_arg('filter') == 'lookahead' %]
  BOOST_AUTO(filter, (FilterFactory::createLookaheadPF(m, *sim, filterResam)));
  [% ELSIF client.get_named_arg('filter') == 'bridge' %]
  BOOST_AUTO(filter, (FilterFactory::createBridgePF(m, *sim, filterResam)));
  [% ELSIF client.get_named_arg('filter') == 'adaptive' %]
  BOOST_AUTO(filter, (FilterFactory::createAdaptivePF(m, *sim, filterResam, stopper, NPARTICLES, BLOCK_PARTICLES)));
  [% ELSE %]
  BOOST_AUTO(filter, (FilterFactory::createBootstrapPF(m, *sim, filterResam)));
  [% END %]
  
  /* sample stopper */
  [% IF client.get_named_arg('stopper') == 'deterministic' %]
  Stopper sampleStopper(STOPPER_THRESHOLD, NSAMPLES, sched.numObs());
  [% ELSIF client.get_named_arg('stopper') == 'sumofweights' %]
  SumOfWeightsStopper sampleStopper(STOPPER_THRESHOLD, NSAMPLES, sched.numObs());
  [% ELSIF client.get_named_arg('stopper') == 'miness' %]
  MinimumESSStopper sampleStopper(STOPPER_THRESHOLD, NSAMPLES, sched.numObs());
  [% ELSIF client.get_named_arg('stopper') == 'stddev' %]
  StdDevStopper sampleStopper(STOPPER_THRESHOLD, NSAMPLES, sched.numObs());
  [% ELSIF client.get_named_arg('stopper') == 'var' %]
  VarStopper sampleStopper(STOPPER_THRESHOLD, NSAMPLES, sched.numObs());
  [% END %]
  
  /* sampler */
  [% IF client.get_named_arg('sampler') == 'sir' %]
  BOOST_AUTO(mmh, SamplerFactory::createMarginalMH(m, *filter));
  BOOST_AUTO(sampler, SamplerFactory::createMarginalSIR(m, *mmh, adapter, resam, NMOVES));
  [% ELSIF client.get_named_arg('sampler') == 'sis' %]
  BOOST_AUTO(sampler, SamplerFactory::createMarginalSIS(m, *filter, adapter, sampleStopper));
  [% ELSE %]
  BOOST_AUTO(sampler, SamplerFactory::createMarginalMH(m, *filter));
  [% END %]

  /* sample */
  #ifdef ENABLE_GPERFTOOLS
  ProfilerStart(GPERFTOOLS_FILE.c_str());
  #endif
  #ifdef ENABLE_TIMING
  TicToc timer;
  #endif

  [% IF client.get_named_arg('target') == 'posterior' %]
  sampler->sample(rng, sched.begin(), sched.end(), s, NSAMPLES, out, bufInit);
  [% ELSE %]
  sim->simulate(rng, sched.begin(), sched.end(), s, out, bufInit);
  [% END %]
  out.flush();
  
  #ifdef ENABLE_TIMING
  /* output timing results */
  timer.sync();
  if (rank == 0) {
    std::cout << "total " << timer.toc() << " us" << std::endl;
  }
  #endif
  #ifdef ENABLE_GPERFTOOLS
  ProfilerStop();
  #endif

  delete sampler;
  delete filter;
  delete sim;
  
  #ifdef ENABLE_MPI
  client.disconnect();
  #endif
}
