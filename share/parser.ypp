%code requires {
#include "bi/program/BinaryExpression.hpp"
#include "bi/program/Braces.hpp"
#include "bi/program/Brackets.hpp"
#include "bi/program/Conditional.hpp"
#include "bi/program/Def.hpp"
#include "bi/program/Dim.hpp"
#include "bi/program/EmptyExpression.hpp"
#include "bi/program/Literal.hpp"
#include "bi/program/Loop.hpp"
#include "bi/program/Parentheses.hpp"
#include "bi/program/Program.hpp"
#include "bi/program/Operator.hpp"
#include "bi/program/Reference.hpp"
#include "bi/program/ReturnExpression.hpp"
#include "bi/program/Sequence.hpp"
#include "bi/program/UnaryExpression.hpp"
#include "bi/program/Var.hpp"

#include "boost/typeof/typeof.hpp"
#include "boost/shared_ptr.hpp"

#include <cstdio>
#include <iostream>
#include <string>
}

%{
#include "parser.hpp"

#define BI_SP(x) boost::shared_ptr<BOOST_TYPEOF(*x)>(x)
#define BI_EMPTY new biprog::EmptyExpression()

biprog::Program program;

extern FILE *yyin;
extern int col;
extern int line;

extern int yylex();
extern int yyparse();

void yyerror(const char *msg) {
  std::cerr << "Error (line " << line << " col " << col << "): " << msg << std::endl;
  exit(-1);
}

void yywarn(const char *msg) {
  std::cerr << "Warning (line " << line << " col " << col << "): " << msg << std::endl;
}

%}

%union {
  bool valBool;
  int valInt;
  double valDouble;
  char* valString;

  biprog::Operator valOperator;
  biprog::Typed* valTyped;
}

%token DEF DIM VAR INHERITS IF ELSE WHILE RETURN
%token <valString> IDENTIFIER
%token <valBool> BOOL_LITERAL
%token <valInt> INT_LITERAL
%token <valDouble> DOUBLE_LITERAL
%token <valString> STRING_LITERAL
%token <valString> RIGHT_ARROW LEFT_ARROW RIGHT_DOUBLE_ARROW DOUBLE_DOT
%token <valString> RIGHT_OP LEFT_OP AND_OP OR_OP LE_OP GE_OP EQ_OP NE_OP
%token <valString> POW_OP ELEM_MUL_OP ELEM_DIV_OP ELEM_POW_OP
%token ENDL
%token OTHER

%type <valOperator> traversal_operator type_operator default_operator
%type <valOperator> unary_operator pow_operator multiplicative_operator
%type <valOperator> additive_operator shift_operator relational_operator
%type <valOperator> equality_operator and_operator exclusive_or_operator
%type <valOperator> inclusive_or_operator logical_and_operator
%type <valOperator> logical_or_operator constraint_operator
%type <valOperator> assignment_operator tuple_operator statement_operator

%type <valTyped> type reference parens brackets braces
%type <valTyped> optional_parens optional_brackets optional_braces
%type <valTyped> bool_literal int_literal double_literal string_literal
%type <valTyped> traversal_expression type_expression primary_expression
%type <valTyped> default_expression unary_expression pow_expression
%type <valTyped> multiplicative_expression additive_expression
%type <valTyped> shift_expression relational_expression
%type <valTyped> equality_expression and_expression
%type <valTyped> exclusive_or_expression inclusive_or_expression
%type <valTyped> logical_and_expression logical_or_expression
%type <valTyped> constraint_expression assignment_expression
%type <valTyped> tuple_expression expression optional_expression
%type <valTyped> optional_type def dim var if while return
%type <valTyped> block_statement nonblock_statement tail_statement statement
%type <valTyped> statements optional_statements file

%start file
%%


/***************************************************************************
 * References                                                              *
 ***************************************************************************/

type
    : IDENTIFIER optional_parens  { $$ = new biprog::Reference($1, BI_SP(BI_EMPTY), BI_SP($2), BI_SP(BI_EMPTY), BI_SP(BI_EMPTY), BI_SP(BI_EMPTY)); }
    ;

reference
    : IDENTIFIER optional_brackets optional_parens optional_braces  { $$ = new biprog::Reference($1, BI_SP($2), BI_SP($3), BI_SP(BI_EMPTY), BI_SP($4), BI_SP(BI_EMPTY)); }
    ;

optional_parens
    : parens
    |         { $$ = BI_EMPTY; }
    ;

optional_brackets
    : brackets
    |           { $$ = BI_EMPTY; }
    ;
    
optional_braces
    : braces
    |         { $$ = BI_EMPTY; }
    ;

parens
    : '(' optional_expression ')'  { $$ = new biprog::Parentheses(BI_SP($2)); }
    ;
    
brackets
    : '[' expression ']'  { $$ = new biprog::Brackets(BI_SP($2)); }
    ;

braces
    : '{'  { program.push(new biprog::Braces()); }  optional_statements '}'  { program.top()->expr = BI_SP($3); $$ = program.pop(); }
    ;


/***************************************************************************
 * Literals                                                                *
 ***************************************************************************/

bool_literal
    : BOOL_LITERAL  { $$ = new biprog::Literal<bool>($1); }
    ;

int_literal
    : INT_LITERAL  { $$ = new biprog::Literal<int>($1); }
    ;

double_literal
    : DOUBLE_LITERAL  { $$ = new biprog::Literal<double>($1); }
    ;

string_literal
    : STRING_LITERAL  { $$ = new biprog::Literal<std::string>($1); }
    ;


/***************************************************************************
 * Expressions                                                             *
 ***************************************************************************/
    
traversal_operator
    : '.'  { $$ = biprog::OP_TRAVERSE; }
    ;
    
traversal_expression
    : reference
    | traversal_expression traversal_operator reference  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;
    
type_operator
    : ':'  { $$ = biprog::OP_TYPE; }
    ;
    
type_expression
    : traversal_expression
    | type_expression type_operator traversal_expression  { $1->type = BI_SP($3); $$ = $1; }
    ;
    
primary_expression
    : type_expression
    | bool_literal
    | int_literal
    | double_literal
    | string_literal
    | parens
    | braces
    ;

default_operator
    : '?'  { $$ = biprog::OP_DEFAULT; }
    ;

default_expression
    : primary_expression
    | primary_expression default_operator default_expression { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

unary_operator
    : '+'  { $$ = biprog::OP_POS; }
    | '-'  { $$ = biprog::OP_NEG; }
    | '!'  { $$ = biprog::OP_NOT; }
    ;
    
unary_expression
    : default_expression
    | unary_operator unary_expression  { $$ = new biprog::UnaryExpression($1, BI_SP($2)); }
    ;

pow_operator
    : POW_OP       { $$ = biprog::OP_POW; }
    | ELEM_POW_OP  { $$ = biprog::OP_ELEM_POW; }
    ;

pow_expression
    : unary_expression
    | pow_expression pow_operator unary_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

multiplicative_operator
    : '*'          { $$ = biprog::OP_MUL; }
    | ELEM_MUL_OP  { $$ = biprog::OP_ELEM_MUL; }
    | '/'          { $$ = biprog::OP_DIV; }
    | ELEM_DIV_OP  { $$ = biprog::OP_ELEM_DIV; }
    | '%'          { $$ = biprog::OP_MOD; }
    ;

multiplicative_expression
    : pow_expression
    | multiplicative_expression multiplicative_operator pow_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

additive_operator
    : '+'  { $$ = biprog::OP_ADD; }
    | '-'  { $$ = biprog::OP_SUB; }
    ;

additive_expression
    : multiplicative_expression
    | additive_expression additive_operator multiplicative_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

shift_operator
    : LEFT_OP   { $$ = biprog::OP_LEFT; }
    | RIGHT_OP  { $$ = biprog::OP_RIGHT; }
    ;

shift_expression
    : additive_expression
    | shift_expression shift_operator additive_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

relational_operator
    : '<'    { $$ = biprog::OP_LT; }
    | '>'    { $$ = biprog::OP_GT; }
    | LE_OP  { $$ = biprog::OP_LE; }
    | GE_OP  { $$ = biprog::OP_GE; }
    ;
    
relational_expression
    : shift_expression
    | relational_expression relational_operator shift_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

equality_operator
    : EQ_OP  { $$ = biprog::OP_EQ; }
    | NE_OP  { $$ = biprog::OP_NE; }
    ;

equality_expression
    : relational_expression
    | equality_expression equality_operator relational_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

and_operator
    : '&'  { $$ = biprog::OP_BIT_AND; }
    ;
    
and_expression
	: equality_expression
	| and_expression and_operator equality_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
	;

exclusive_or_operator
    : '^'  { $$ = biprog::OP_BIT_XOR; }
    ;

exclusive_or_expression
	: and_expression
	| exclusive_or_expression exclusive_or_operator and_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
	;

inclusive_or_operator
    : '|'  { $$ = biprog::OP_BIT_OR; }
    ;

inclusive_or_expression
	: exclusive_or_expression
	| inclusive_or_expression inclusive_or_operator exclusive_or_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }

logical_and_operator
    : AND_OP  { $$ = biprog::OP_AND; }
    ;

logical_and_expression
    : inclusive_or_expression
    | logical_and_expression logical_and_operator equality_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

logical_or_operator
    : OR_OP  { $$ = biprog::OP_OR; }
    ;

logical_or_expression
    : logical_and_expression
    | logical_or_expression logical_or_operator logical_and_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

constraint_operator
    : '='  { $$ = biprog::OP_EQUALS; }
    | '~'  { $$ = biprog::OP_SIMTO; }
    ;

constraint_expression
    : logical_or_expression
    | logical_or_expression constraint_operator constraint_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

assignment_operator
    : LEFT_ARROW  { $$ = biprog::OP_LEFT_ARROW; }
    ;

assignment_expression
    : constraint_expression
    | constraint_expression assignment_operator assignment_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

tuple_operator
    : ','  { $$ = biprog::OP_COMMA; }
    ;
    
tuple_expression
    : assignment_expression
    | tuple_expression tuple_operator assignment_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

expression
    : tuple_expression
    ;
    
optional_expression
    : expression
    |             { $$ = BI_EMPTY; }
    ;


/***************************************************************************
 * Statements                                                              *
 ***************************************************************************/

optional_type
    : type_operator type  { $$ = $2; }
    |                     { $$ = BI_EMPTY; }
    ;

statement_operator
    : ';'  { $$ = biprog::OP_SEMICOLON; }
    ;

def
    : DEF IDENTIFIER optional_parens optional_type braces              { $$ = new biprog::Def($2, BI_SP($3), BI_SP($4), BI_SP($5)); }
    | DEF IDENTIFIER optional_parens optional_type statement_operator  { $$ = new biprog::Def($2, BI_SP($3), BI_SP($4), BI_SP(BI_EMPTY)); }
    ;

dim
    : DIM IDENTIFIER brackets  { $$ = new biprog::Dim($2, BI_SP($3)); }
    ;

var
    : VAR IDENTIFIER optional_brackets type_operator type  { $$ = new biprog::Var($2, BI_SP($3), BI_SP($5)); }
    ;

if
    : IF parens braces ELSE if      { $$ = new biprog::Conditional(BI_SP($2), BI_SP($3), BI_SP($5)); }
    | IF parens braces ELSE braces  { $$ = new biprog::Conditional(BI_SP($2), BI_SP($3), BI_SP($5)); }
    | IF parens braces              { $$ = new biprog::Conditional(BI_SP($2), BI_SP($3), BI_SP(BI_EMPTY)); }
    ;

while
    : WHILE parens braces  { $$ = new biprog::Loop(BI_SP($2), BI_SP($3)); }
    ;

return
    : RETURN expression  { $$ = new biprog::ReturnExpression(BI_SP($2)); }
    ;

block_statement
    : def
    | if
    | while
    ;
    
nonblock_statement
    : dim
    | var
    | return
    | expression
    ;
    
statement
    : block_statement
    | nonblock_statement statement_operator
    ;
    
tail_statement
    : expression
    ;

optional_statements
    : statements
    |             { $$ = BI_EMPTY; }
    ;
    
statements
    : statement
    | tail_statement
    | statement statements  { $$ = new biprog::Sequence(BI_SP($1), BI_SP($2)); }
    ;


/***************************************************************************
 * File                                                                    *
 ***************************************************************************/

file
    : statements  { program.setRoot(BI_SP($1)); }
    ;
    
%%

int main() {
  do {
    yyparse();
  } while (!feof(yyin));
  std::cout << *program.getRoot() << std::endl;

  return 0;
}
