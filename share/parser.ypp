%code requires {
#include "bi/program/BinaryExpression.hpp"
#include "bi/program/Conditional.hpp"
#include "bi/program/Dim.hpp"
#include "bi/program/EmptyExpression.hpp"
#include "bi/program/FunctionOverload.hpp"
#include "bi/program/Group.hpp"
#include "bi/program/Literal.hpp"
#include "bi/program/Loop.hpp"
#include "bi/program/MethodOverload.hpp"
#include "bi/program/Model.hpp"
#include "bi/program/Program.hpp"
#include "bi/program/Operator.hpp"
#include "bi/program/Reference.hpp"
#include "bi/program/Type.hpp"
#include "bi/program/UnaryExpression.hpp"
#include "bi/program/Var.hpp"

#include "boost/typeof/typeof.hpp"
#include "boost/shared_ptr.hpp"

#include <cstdio>
#include <iostream>
#include <string>
}

%{
#include "parser.hpp"

#define BI_SP(x) boost::shared_ptr<biprog::Expression>(x)
#define BI_SP_EMPTY boost::shared_ptr<biprog::Expression>(new biprog::EmptyExpression())

biprog::Program program;

extern FILE *yyin;
extern int col;
extern int line;

extern int yylex();
extern int yyparse();

void yyerror(const char *msg) {
  std::cerr << "Error (line " << line << " col " << col << "): " << msg << std::endl;
  exit(-1);
}

void yywarn(const char *msg) {
  std::cerr << "Warning (line " << line << " col " << col << "): " << msg << std::endl;
}

%}

%union {
  bool valBool;
  int valInt;
  double valDouble;
  char* valString;
    
  biprog::Type* valType;
  biprog::Operator valOperator;
  biprog::Expression* valExpression;
}

%token MODEL FUNCTION METHOD BUILTIN DIM VAR IF WHILE
%token <valString> IDENTIFIER
%token <valBool> BOOL_LITERAL
%token <valInt> INT_LITERAL
%token <valDouble> DOUBLE_LITERAL
%token <valString> STRING_LITERAL
%token <valString> RIGHT_ARROW LEFT_ARROW RIGHT_DOUBLE_ARROW DOUBLE_DOT
%token <valString> RIGHT_OP LEFT_OP AND_OP OR_OP LE_OP GE_OP EQ_OP NE_OP
%token <valString> POW_OP ELEM_MUL_OP ELEM_DIV_OP ELEM_POW_OP
%token ENDL
%token OTHER

%type <valType> type

%type <valOperator> traversal_operator type_operator default_operator
%type <valOperator> unary_operator pow_operator multiplicative_operator
%type <valOperator> additive_operator shift_operator relational_operator
%type <valOperator> equality_operator and_operator exclusive_or_operator
%type <valOperator> inclusive_or_operator logical_and_operator
%type <valOperator> logical_or_operator constraint_operator
%type <valOperator> assignment_operator tuple_operator statement_operator

%type <valExpression> reference parens brackets braces
%type <valExpression> bool_literal int_literal double_literal string_literal
%type <valExpression> traversal_expression type_expression primary_expression
%type <valExpression> default_expression unary_expression pow_expression
%type <valExpression> multiplicative_expression additive_expression
%type <valExpression> shift_expression relational_expression
%type <valExpression> equality_expression and_expression
%type <valExpression> exclusive_or_expression inclusive_or_expression
%type <valExpression> logical_and_expression logical_or_expression
%type <valExpression> constraint_expression assignment_expression
%type <valExpression> tuple_expression expression
%type <valExpression> model method function dim var if while statement statements

%start file
%%


/***************************************************************************
 * Expressions                                                             *
 ***************************************************************************/

type
    : IDENTIFIER  { $$ = new biprog::Type($1); }
    ;

reference
    : IDENTIFIER                { $$ = new biprog::Reference($1, BI_SP_EMPTY, BI_SP_EMPTY, BI_SP_EMPTY, program.lookup($1)); }
    | IDENTIFIER brackets       { $$ = new biprog::Reference($1, BI_SP($2), BI_SP_EMPTY, BI_SP_EMPTY, program.lookup($1)); }
    | IDENTIFIER parens         { $$ = new biprog::Reference($1, BI_SP_EMPTY, BI_SP($2), BI_SP_EMPTY, program.lookup($1)); }
    | IDENTIFIER braces         { $$ = new biprog::Reference($1, BI_SP_EMPTY, BI_SP_EMPTY, BI_SP($2), program.lookup($1)); }
    | IDENTIFIER parens braces  { $$ = new biprog::Reference($1, BI_SP_EMPTY, BI_SP($2), BI_SP($3), program.lookup($1)); }
    ;

parens
    : '(' expression ')'  { $$ = new biprog::Group(biprog::PARENS, BI_SP($2)); }
    | '(' ')'             { $$ = new biprog::Group(biprog::PARENS, BI_SP_EMPTY); }
    ;
    
brackets
    : '[' expression ']'  { $$ = new biprog::Group(biprog::BRACKETS, BI_SP($2)); }
    ;

braces
    : '{' { program.push(); } statements '}' { program.pop(); }  { $$ = new biprog::Group(biprog::BRACES, BI_SP($3)); }
    | '{'  '}'                                                   { $$ = new biprog::Group(biprog::BRACES, BI_SP_EMPTY); }
    ;

bool_literal
    : BOOL_LITERAL  { $$ = new biprog::Literal<bool>($1); }
    ;

int_literal
    : INT_LITERAL  { $$ = new biprog::Literal<int>($1); }
    ;

double_literal
    : DOUBLE_LITERAL  { $$ = new biprog::Literal<double>($1); }
    ;

string_literal
    : STRING_LITERAL  { $$ = new biprog::Literal<std::string>($1); }
    ;
    
traversal_operator
    : '.'  { $$ = biprog::OP_TRAVERSE; }
    ;
    
traversal_expression
    : reference
    | traversal_expression traversal_operator reference  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;
    
type_operator
    : ':'  { $$ = biprog::OP_TYPE; }
    ;
    
type_expression
    : traversal_expression
    | traversal_expression type_operator type  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;
    
primary_expression
    : type_expression
    | bool_literal
    | int_literal
    | double_literal
    | string_literal
    | parens
    | braces
    ;

default_operator
    : '?'  { $$ = biprog::OP_DEFAULT; }
    ;

default_expression
    : primary_expression
    | primary_expression default_operator default_expression { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

unary_operator
    : '+'  { $$ = biprog::OP_POS; }
    | '-'  { $$ = biprog::OP_NEG; }
    | '!'  { $$ = biprog::OP_NOT; }
    ;
    
unary_expression
    : default_expression
    | unary_operator unary_expression  { $$ = new biprog::UnaryExpression($1, BI_SP($2)); }
    ;

pow_operator
    : POW_OP       { $$ = biprog::OP_POW; }
    | ELEM_POW_OP  { $$ = biprog::OP_ELEM_POW; }
    ;

pow_expression
    : unary_expression
    | pow_expression pow_operator unary_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

multiplicative_operator
    : '*'          { $$ = biprog::OP_MUL; }
    | ELEM_MUL_OP  { $$ = biprog::OP_ELEM_MUL; }
    | '/'          { $$ = biprog::OP_DIV; }
    | ELEM_DIV_OP  { $$ = biprog::OP_ELEM_DIV; }
    | '%'          { $$ = biprog::OP_MOD; }
    ;

multiplicative_expression
    : pow_expression
    | multiplicative_expression multiplicative_operator pow_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

additive_operator
    : '+'          { $$ = biprog::OP_ADD; }
    | '-'          { $$ = biprog::OP_SUB; }
    ;

additive_expression
    : multiplicative_expression
    | additive_expression additive_operator multiplicative_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

shift_operator
    : LEFT_OP   { $$ = biprog::OP_LEFT; }
    | RIGHT_OP  { $$ = biprog::OP_RIGHT; }
    ;

shift_expression
    : additive_expression
    | shift_expression shift_operator additive_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

relational_operator
    : '<'    { $$ = biprog::OP_LT; }
    | '>'    { $$ = biprog::OP_GT; }
    | LE_OP  { $$ = biprog::OP_LE; }
    | GE_OP  { $$ = biprog::OP_GE; }
    ;
    
relational_expression
    : shift_expression
    | relational_expression relational_operator shift_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

equality_operator
    : EQ_OP  { $$ = biprog::OP_EQ; }
    | NE_OP  { $$ = biprog::OP_NE; }
    ;

equality_expression
    : relational_expression
    | equality_expression equality_operator relational_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

and_operator
    : '&'  { $$ = biprog::OP_BIT_AND; }
    ;
    
and_expression
	: equality_expression
	| and_expression and_operator equality_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
	;

exclusive_or_operator
    : '^'  { $$ = biprog::OP_BIT_XOR; }
    ;

exclusive_or_expression
	: and_expression
	| exclusive_or_expression exclusive_or_operator and_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
	;

inclusive_or_operator
    : '|'  { $$ = biprog::OP_BIT_OR; }
    ;

inclusive_or_expression
	: exclusive_or_expression
	| inclusive_or_expression inclusive_or_operator exclusive_or_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }

logical_and_operator
    : AND_OP  { $$ = biprog::OP_AND; }
    ;

logical_and_expression
    : inclusive_or_expression
    | logical_and_expression logical_and_operator equality_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

logical_or_operator
    : OR_OP  { $$ = biprog::OP_OR; }
    ;

logical_or_expression
    : logical_and_expression
    | logical_or_expression logical_or_operator logical_and_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

constraint_operator
    : '='  { $$ = biprog::OP_EQUALS; }
    | '~'  { $$ = biprog::OP_SIMTO; }
    ;

constraint_expression
    : logical_or_expression
    | logical_or_expression constraint_operator constraint_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

assignment_operator
    : LEFT_ARROW  { $$ = biprog::OP_LEFT_ARROW; }
    ;

assignment_expression
    : constraint_expression
    | constraint_expression assignment_operator assignment_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

tuple_operator
    : ','  { $$ = biprog::OP_COMMA; }
    ;
    
tuple_expression
    : assignment_expression
    | tuple_expression tuple_operator assignment_expression  { $$ = new biprog::BinaryExpression(BI_SP($1), $2, BI_SP($3)); }
    ;

expression
    : tuple_expression
    ;


/***************************************************************************
 * Statements                                                              *
 ***************************************************************************/

statement_operator
    : ';'  { $$ = biprog::OP_SEMICOLON; }
    ;

model
    : MODEL IDENTIFIER parens braces              { $$ = new biprog::Model($2, BI_SP($3), BI_SP($4), program.top()); }
    | MODEL IDENTIFIER braces                     { $$ = new biprog::Model($2, BI_SP_EMPTY, BI_SP($3), program.top()); }
    | MODEL IDENTIFIER parens statement_operator  { $$ = new biprog::Model($2, BI_SP($3), BI_SP_EMPTY, program.top()); }
    | MODEL IDENTIFIER statement_operator         { $$ = new biprog::Model($2, BI_SP_EMPTY, BI_SP_EMPTY, program.top()); }
    ;
    
method
    : METHOD IDENTIFIER parens braces              { $$ = new biprog::MethodOverload($2, BI_SP($3), BI_SP($4), program.top()); }
    | METHOD IDENTIFIER braces                     { $$ = new biprog::MethodOverload($2, BI_SP_EMPTY, BI_SP($3), program.top()); }
    | METHOD IDENTIFIER parens statement_operator  { $$ = new biprog::MethodOverload($2, BI_SP($3), BI_SP_EMPTY, program.top()); }
    | METHOD IDENTIFIER statement_operator         { $$ = new biprog::MethodOverload($2, BI_SP_EMPTY, BI_SP_EMPTY, program.top()); }
    ;

function
    : FUNCTION IDENTIFIER parens RIGHT_ARROW parens braces              { $$ = new biprog::FunctionOverload($2, BI_SP($3), BI_SP($5), program.top()); }
    | FUNCTION IDENTIFIER parens RIGHT_ARROW parens statement_operator  { $$ = new biprog::FunctionOverload($2, BI_SP($3), BI_SP_EMPTY, program.top()); }
    ;

dim
    : DIM IDENTIFIER brackets statement_operator  { $$ = new biprog::Dim($2, BI_SP($3)); }
    ;

var
    : VAR IDENTIFIER type_operator type statement_operator           { $$ = new biprog::Var($2, BI_SP_EMPTY, $4); }
    | VAR IDENTIFIER brackets type_operator type statement_operator  { $$ = new biprog::Var($2, BI_SP($3), $5); }
    ;

if
    : IF parens braces  { $$ = new biprog::Conditional(BI_SP($2), BI_SP($3), program.top()); }
    ;

while
    : WHILE parens braces  { $$ = new biprog::Loop(BI_SP($2), BI_SP($3), program.top()); }
    ;

statement
    : model
    | method
    | function
    | dim
    | var
    | if
    | while
    | expression statement_operator
    ;
    
statements
    : statement
    | expression
    | statement statements  { boost::shared_ptr<biprog::Expression> expr = BI_SP($1); program.add(expr); $$ = new biprog::BinaryExpression(expr, biprog::OP_SEMICOLON, BI_SP($2)); }
    ;


/***************************************************************************
 * File                                                                    *
 ***************************************************************************/

file
    : statements  { boost::shared_ptr<biprog::Expression> expr = BI_SP($1); program.add(expr); program.setRoot(expr); }
    |
    ;
    
%%

int main() {
  do {
    yyparse();
  } while (!feof(yyin));
  std::cout << *program.getRoot() << std::endl;

  return 0;
}
