%code requires {
#include "bi/program/BinaryExpression.hpp"
#include "bi/program/Conditional.hpp"
#include "bi/program/Dim.hpp"
#include "bi/program/Function.hpp"
#include "bi/program/Literal.hpp"
#include "bi/program/Loop.hpp"
#include "bi/program/Match.hpp"
#include "bi/program/Method.hpp"
#include "bi/program/Model.hpp"
#include "bi/program/Operator.hpp"
#include "bi/program/Reference.hpp"
#include "bi/program/Sequence.hpp"
#include "bi/program/Type.hpp"
#include "bi/program/UnaryExpression.hpp"
#include "bi/program/Var.hpp"

#include "boost/typeof/typeof.hpp"

#include <cstdio>
#include <iostream>
#include <deque>
#include <map> //#include <unordered_map>
#include <string>
#include <algorithm>

}

%{
#include "parser.hpp"

extern int yylex();
extern int yyparse();
extern FILE *yyin;

extern int col;
extern int line;

typedef std::multimap<std::string,biprog::Declaration*> scope_type;
///@todo std::unordered_multimap preferable after C++11 transition

std::deque<scope_type> scopes;

void yyerror(const char *msg) {
  std::cerr << "Error (line " << line << " col " << col << "): " << msg << std::endl;
  exit(-1);
}

void yywarn(const char *msg) {
  std::cerr << "Warning (line " << line << " col " << col << "): " << msg << std::endl;
}

void push_scope() {
  scopes.push_front(scope_type());
}

void pop_scope() {
  scopes.pop_front();
}

biprog::Declaration* add(biprog::Declaration* decl) {
  scopes.front().insert(std::make_pair(decl->name, decl));
  return decl;
}

biprog::Reference* match(biprog::Reference* ref) {
  std::deque<biprog::Match> matches;
  biprog::Match match;
  
  BOOST_AUTO(scope, scopes.begin());
  bool found = false;
  while (!found && scope != scopes.end()) {
    BOOST_AUTO(decls, scope->equal_range(ref->name));
    found = decls.first != decls.second;

    BOOST_AUTO(decl, decls.first);
    while (decl != decls.second) {
      if (decl->second->match(ref, match)) {
        matches.push_back(match);
        match.clear();
      }
      ++decl;
    }
    ++scope;
  }
  
  if (matches.size() > 0) {
    std::sort(matches.begin(), matches.end());
  } else {
    yywarn("no match for symbol");
  }

  return ref;
}

%}

%union {
    bool valBool;
    int valInt;
    double valDouble;
    char* valString;
    
    biprog::Type* valType;
    biprog::Operator valOperator;
    biprog::Expression* valExpression;
}

%token MODEL FUNCTION METHOD BUILTIN DIM VAR IF WHILE
%token <valString> IDENTIFIER
%token <valBool> BOOL_LITERAL
%token <valInt> INT_LITERAL
%token <valDouble> DOUBLE_LITERAL
%token <valString> STRING_LITERAL
%token <valString> RIGHT_ARROW LEFT_ARROW RIGHT_DOUBLE_ARROW DOUBLE_DOT
%token <valString> RIGHT_OP LEFT_OP AND_OP OR_OP LE_OP GE_OP EQ_OP NE_OP
%token <valString> POW_OP ELEM_MUL_OP ELEM_DIV_OP ELEM_POW_OP
%token ENDL
%token OTHER

%type <valType> type

%type <valOperator> traversal_operator type_operator default_operator
%type <valOperator> unary_operator pow_operator multiplicative_operator
%type <valOperator> additive_operator shift_operator relational_operator
%type <valOperator> equality_operator and_operator exclusive_or_operator
%type <valOperator> inclusive_or_operator logical_and_operator
%type <valOperator> logical_or_operator constraint_operator
%type <valOperator> assignment_operator tuple_operator statement_operator

%type <valExpression> reference parens brackets braces
%type <valExpression> bool_literal int_literal double_literal string_literal
%type <valExpression> traversal_expression type_expression primary_expression
%type <valExpression> default_expression unary_expression pow_expression
%type <valExpression> multiplicative_expression additive_expression
%type <valExpression> shift_expression relational_expression
%type <valExpression> equality_expression and_expression
%type <valExpression> exclusive_or_expression inclusive_or_expression
%type <valExpression> logical_and_expression logical_or_expression
%type <valExpression> constraint_expression assignment_expression
%type <valExpression> tuple_expression expression
%type <valExpression> model method function dim var if while statement statements

%start file
%%


/***************************************************************************
 * Expressions                                                             *
 ***************************************************************************/

type
    : IDENTIFIER  { $$ = new biprog::Type($1); }
    ;

reference
    : IDENTIFIER                { $$ = match(new biprog::Reference($1)); }
    | IDENTIFIER brackets       { $$ = match(new biprog::Reference($1, $2)); }
    | IDENTIFIER parens         { $$ = match(new biprog::Reference($1, NULL, $2)); }
    | IDENTIFIER braces         { $$ = match(new biprog::Reference($1, NULL, NULL, $2)); }
    | IDENTIFIER parens braces  { $$ = match(new biprog::Reference($1, NULL, $2, $3)); }
    ;

parens
    : '(' expression ')'  { $$ = $2; }
    | '(' ')'             { $$ = NULL; }
    ;
    
brackets
    : '[' expression ']'  { $$ = $2; }
    ;

braces
    : '{' { push_scope(); } statements '}' { pop_scope(); }  { $$ = $3; }
    | '{' '}'                                                { $$ = NULL; }
    ;

bool_literal
    : BOOL_LITERAL  { $$ = new biprog::Literal<bool>($1); }
    ;

int_literal
    : INT_LITERAL  { $$ = new biprog::Literal<int>($1); }
    ;

double_literal
    : DOUBLE_LITERAL  { $$ = new biprog::Literal<double>($1); }
    ;

string_literal
    : STRING_LITERAL  { $$ = new biprog::Literal<std::string>($1); }
    ;
    
traversal_operator
    : '.'  { $$ = biprog::OP_TRAVERSE; }
    ;
    
traversal_expression
    : reference
    | traversal_expression traversal_operator reference  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;
    
type_operator
    : ':'  { $$ = biprog::OP_TYPE; }
    ;
    
type_expression
    : traversal_expression
    | traversal_expression type_operator type  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;
    
primary_expression
    : type_expression
    | bool_literal
    | int_literal
    | double_literal
    | string_literal
    | parens
    | braces
    ;

default_operator
    : '?'  { $$ = biprog::OP_DEFAULT; }
    ;

default_expression
    : primary_expression
    | primary_expression default_operator default_expression { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

unary_operator
    : '+'  { $$ = biprog::OP_POS; }
    | '-'  { $$ = biprog::OP_NEG; }
    | '!'  { $$ = biprog::OP_NOT; }
    ;
    
unary_expression
    : default_expression
    | unary_operator unary_expression  { $$ = new biprog::UnaryExpression($1, $2); }
    ;

pow_operator
    : POW_OP       { $$ = biprog::OP_POW; }
    | ELEM_POW_OP  { $$ = biprog::OP_ELEM_POW; }
    ;

pow_expression
    : unary_expression
    | pow_expression pow_operator unary_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

multiplicative_operator
    : '*'          { $$ = biprog::OP_MUL; }
    | ELEM_MUL_OP  { $$ = biprog::OP_ELEM_MUL; }
    | '/'          { $$ = biprog::OP_DIV; }
    | ELEM_DIV_OP  { $$ = biprog::OP_ELEM_DIV; }
    | '%'          { $$ = biprog::OP_MOD; }
    ;

multiplicative_expression
    : pow_expression
    | multiplicative_expression multiplicative_operator pow_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

additive_operator
    : '+'          { $$ = biprog::OP_ADD; }
    | '-'          { $$ = biprog::OP_SUB; }
    ;

additive_expression
    : multiplicative_expression
    | additive_expression additive_operator multiplicative_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

shift_operator
    : LEFT_OP   { $$ = biprog::OP_LEFT; }
    | RIGHT_OP  { $$ = biprog::OP_RIGHT; }
    ;

shift_expression
    : additive_expression
    | shift_expression shift_operator additive_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

relational_operator
    : '<'    { $$ = biprog::OP_LT; }
    | '>'    { $$ = biprog::OP_GT; }
    | LE_OP  { $$ = biprog::OP_LE; }
    | GE_OP  { $$ = biprog::OP_GE; }
    ;
    
relational_expression
    : shift_expression
    | relational_expression relational_operator shift_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

equality_operator
    : EQ_OP  { $$ = biprog::OP_EQ; }
    | NE_OP  { $$ = biprog::OP_NE; }
    ;

equality_expression
    : relational_expression
    | equality_expression equality_operator relational_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

and_operator
    : '&'  { $$ = biprog::OP_BIT_AND; }
    ;
    
and_expression
	: equality_expression
	| and_expression and_operator equality_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
	;

exclusive_or_operator
    : '^'  { $$ = biprog::OP_BIT_XOR; }
    ;

exclusive_or_expression
	: and_expression
	| exclusive_or_expression exclusive_or_operator and_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
	;

inclusive_or_operator
    : '|'  { $$ = biprog::OP_BIT_OR; }
    ;

inclusive_or_expression
	: exclusive_or_expression
	| inclusive_or_expression inclusive_or_operator exclusive_or_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }

logical_and_operator
    : AND_OP  { $$ = biprog::OP_AND; }
    ;

logical_and_expression
    : inclusive_or_expression
    | logical_and_expression logical_and_operator equality_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

logical_or_operator
    : OR_OP  { $$ = biprog::OP_OR; }
    ;

logical_or_expression
    : logical_and_expression
    | logical_or_expression logical_or_operator logical_and_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

constraint_operator
    : '='  { $$ = biprog::OP_EQUALS; }
    | '~'  { $$ = biprog::OP_SIMTO; }
    ;

constraint_expression
    : logical_or_expression
    | logical_or_expression constraint_operator constraint_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

assignment_operator
    : LEFT_ARROW  { $$ = biprog::OP_LEFT_ARROW; }
    ;

assignment_expression
    : constraint_expression
    | constraint_expression assignment_operator assignment_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

tuple_operator
    : ','  { $$ = biprog::OP_COMMA; }
    ;
    
tuple_expression
    : assignment_expression
    | tuple_expression tuple_operator assignment_expression  { $$ = new biprog::BinaryExpression($1, $2, $3); }
    ;

expression
    : tuple_expression
    ;


/***************************************************************************
 * Statements                                                              *
 ***************************************************************************/

statement_operator
    : ';'  { $$ = biprog::OP_SEMICOLON; }
    ;

model
    : MODEL IDENTIFIER parens braces              { $$ = add(new biprog::Model($2, $3, $4)); }
    | MODEL IDENTIFIER braces                     { $$ = add(new biprog::Model($2, NULL, $3)); }
    | MODEL IDENTIFIER parens statement_operator  { $$ = add(new biprog::Model($2, $3)); }
    | MODEL IDENTIFIER statement_operator         { $$ = add(new biprog::Model($2)); }
    ;
    
method
    : METHOD IDENTIFIER parens braces              { $$ = add(new biprog::Method($2, $3, $4)); }
    | METHOD IDENTIFIER braces                     { $$ = add(new biprog::Method($2, NULL, $3)); }
    | METHOD IDENTIFIER parens statement_operator  { $$ = add(new biprog::Method($2, $3)); }
    | METHOD IDENTIFIER statement_operator         { $$ = add(new biprog::Method($2)); }
    ;

function
    : FUNCTION IDENTIFIER parens RIGHT_ARROW parens braces              { $$ = add(new biprog::Function($2, $3, $5, $6)); }
    | FUNCTION IDENTIFIER parens RIGHT_ARROW parens statement_operator  { $$ = add(new biprog::Function($2, $3, $5)); }
    ;

dim
    : DIM IDENTIFIER brackets statement_operator  { $$ = add(new biprog::Dim($2, $3)); }
    ;

var
    : VAR IDENTIFIER type_operator type statement_operator           { $$ = add(new biprog::Var($2, NULL, $4)); }
    | VAR IDENTIFIER brackets type_operator type statement_operator  { $$ = add(new biprog::Var($2, $3, $5)); }
    ;

if
    : IF parens braces  { $$ = new biprog::Conditional($2, $3); }
    ;

while
    : WHILE parens braces  { $$ = new biprog::Loop($2, $3); }
    ;

statement
    : model
    | method
    | function
    | dim
    | var
    | if
    | while
    | expression statement_operator
    ;
    
statements
    : statement
    | expression
    | statement statements  { $$ = new biprog::Sequence($1, $2); }
    ;


/***************************************************************************
 * File                                                                    *
 ***************************************************************************/

file
    : { push_scope(); } statements { pop_scope(); }
    |
    ;
    
%%

int main() {
  do {
    yyparse();
  } while (!feof(yyin));

  return 0;
}
