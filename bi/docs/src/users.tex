\section{Introduction\label{Introduction}}

LibBi is used for Bayesian inference over state-space models, including
simulation, filtering and smoothing for state estimation, and optimisation and
sampling for parameter estimation.

LibBi supports state-space models of the form:
\begin{equation*}
p(\mathbf{y}_{1:T},\mathbf{x}_{1:T},\boldsymbol{\theta}) =
\underbrace{p(\boldsymbol{\theta})}_{\text{parameter}}
\underbrace{p(\mathbf{x}_0|\boldsymbol{\theta})}_{\text{initial}}
\prod_{t=1}^T
\underbrace{p(\mathbf{x}_t|\mathbf{x}_{t-1},\boldsymbol{\theta})}_{\text{transition}}
\underbrace{p(\mathbf{y}_t|\mathbf{x}_t,\boldsymbol{\theta})}_{\text{observation}}.
\end{equation*}
where $t = 1,\ldots,T$ indexes time, $\mathbf{y}_{1:T}$ are observations,
$\mathbf{x}_{1:T}$ are state variables, and $\boldsymbol{\theta}$ are
parameters.

The model is hierarchically factored into four particular conditional
probability densities\index{probability\,density}:
\begin{itemize}
\item the parameter model, specifying the prior density over parameters,
\item the initial condition model, specifying the prior density over initial
  conditions, conditioned on the parameters,
\item the transition model, specifying the transition density conditioned on
  the parameters and previous state,
\item the observation model, specifying the observation density conditioned on
  the parameters and current state.
\end{itemize}
Each of these is explicitly specified using the LibBi modelling
language\seealso{See \secref{Models}{Models}}.

A brief example will help to set the scene. Consider the following
Lotka-Volterra-like\index{Lotka-Volterra} predator-prey\index{predator-prey}
model between zooplankton (predator, $Z$) and phytoplankton (prey, $P$):
\begin{eqnarray*}
\frac{dP}{dt} &=& \alpha_t P - cPZ\\
\frac{dZ}{dt} &=& ecPZ - m_lZ - m_q Z^2.
\end{eqnarray*}
Here, $t$ is time (in days), with prescribed constants $c = .25$, $e = .3$,
$m_l = .1$ and $m_q = .1$. The stochastic growth term, $\alpha_t$, is updated
in discrete time by drawing $\alpha_t \sim \mathcal{N}(\mu,\sigma)$
daily. Parameters to be estimated are $\mu$ and $\sigma$, and $P$ is observed,
with noise, at daily intervals.

The model above might be specified in the LibBi modelling language as follows:
\begin{bicode}
/**
 * Lotka-Volterra-like phytoplankton-zooplankton (PZ) model.
 */
model PZ \{
  const c = 0.25   // zooplankton clearance rate
  const e = 0.3    // zooplankton growth efficiency
  const m_l = 0.1  // zooplankton linear mortality
  const m_q = 0.1  // zooplankton quadratic mortality

  param mu, sigma  // mean and std. dev. of phytoplankton growth
  state P, Z       // phytoplankton, zooplankton
  noise alpha      // stochastic phytoplankton growth rate
  obs P_obs        // observations of phytoplankton
  
  sub parameter \{
    mu ~ uniform(0.0, 1.0)
    sigma ~ uniform(0.0, 0.5)
  \}
  
  sub initial \{
    P ~ log_normal(log(2.0), 0.2)
    Z ~ log_normal(log(2.0), 0.1)
  \}

  sub transition(delta = 1.0) \{
    do \{
      alpha ~ normal(mu, sigma)
    \} then ode(atoler = 1.0e-3, rtoler = 1.0e-3, alg = 'rk4') \{
      P <- ode(alpha*P - c*P*Z)
      Z <- ode(e*c*P*Z - m_l*Z - m_q*Z*Z)
    \}
  \}

  sub observation \{
    P_obs ~ log_normal(log(P), 0.2)
  \}
\}
\end{bicode}

This would be saved in a file named \bitt{PZ.bi}. We can now consider
performing various tasks with the LibBi command-line interface, the simplest of
which is simulating from the model:
\begin{cmdcode}
bi simulate --model-file PZ.bi -P 128 -T 365 -K 365 \textbackslash
    --output-file results/simulate.nc
\end{cmdcode}
This command will simulate 128 trajectories of the model (\bitt{-P 128}), each
of 365 days (\bitt{-T 365}), outputting the results to the NetCDF\index{NetCDF}
file \bitt{results/simulate.nc} every day (\bitt{-K 365}).

\begin{tip}
On the first occasion that a command is run, LibBi generates and compiles code
for you behind the scenes. This takes some time, depending on the complexity
of the model. The second time the command is run there is no such overhead,
and execution time is noticeably shorter. Changes to some command-line options
may also trigger a recompile.
\end{tip}

The \secref{Command_line_interface}{command-line interface} provides numerous
other functionality, including filtering and smoothing the model with respect
to data, and optimising or sampling its parameters.

To play with this example further, download the \bitt{PZ} package from
\url{www.libbi.org}. Inspect and execute the \texttt{run.sh} script to get
started.

\section{Getting started}\label{Getting_started}

There is a standard file and directory structure for a LibBi project. Sticking
to it ensures that your projects will be easy to share and distribute via
LibBi packages. To set up the standard structure, create an empty directory
somewhere, and from within that directory run:
\begin{cmdcode}
bi package --create --name \emph{Name}
\end{cmdcode}
replacing \bitt{\emph{Name}} with the name of your project.

\begin{tip}
By convention, names always begin with an uppercase letter, and multiple words
are denoted using CamelCase. See the \secref{Style_guide}{Style guide} for
more such conventions.
\end{tip}

Each of the files that are created contains some placeholder content that is
intended to be modified. Following this guide, and looking at some existing
examples, is a good way to proceed.

The following command can be run at any time to validate that a project still
conforms to the standard structure:
\begin{cmdcode}
bi package --validate
\end{cmdcode}

Finally, the following command can be used to build a package for
distribution:
\begin{cmdcode}
bi package --build
\end{cmdcode}
This creates a \bitt{*.tar.gz} file in the current directory containing the
project files.

\section{Models\label{Models}}

Models for use with LibBi are specified in the LibBi modelling language. A
model specification is put in a file with an extension of \bitt{*.bi}. Each
such files will contain only a single model specification.

A specification always starts with an outer \kwref{model} statement that
declares and names the model. It then proceeds with declarations of dimensions
and variables, followed by four \emph{top-level blocks} --
\blockref{parameter}, \blockref{initial}, \blockref{transition} and
\blockref{observation} -- that describe the factors of the hierarchical model.

A suitable template is:
\begin{bicode}
model \textsl{Name} \{
  // declare constants...
  // declare dimensions...
  // declare variables...

  sub parameter \{
    // specify the parameter model
  \}

  sub initial \{
    // specify the initial condition model
  \}

  sub transition \{
    // specify the transition model
  \}

  sub observation \{
    // specify the observation model
  \}
\}
\end{bicode}

Note that the contents of the \kwref{model} statement and each top-level block
are contained in curly braces (\bitt{\{\(\ldots\)\}}), in typical
C-style. Comments are also C-style, an inline comment being wrapped by
\bitt{/*} and \bitt{*/}, and the double-slash (\bitt{//}) denoting an
end-of-line comment. Lines may optionally end with a semicolon.

\subsection{Constants\label{Constants}}

\seealso{See also \secref{const}{\kwref{const}}}
Constants are named and immutable scalar values. They are declared using:
\begin{bicode}
const \emph{name} = \emph{constant_expression}
\end{bicode}
Often \bitt{\emph{constant\_expression}} is simply a literal value, but in
general it may be any constant scalar expression (see
\secref{Expressions}{Expressions}).

\subsection{Inlines\label{Inlines}}

\seealso{See also \secref{inline}{\kwref{inline}}}
Inlines are named scalar expressions. They are declared using:
\begin{bicode}
inline \emph{name} = \emph{expression}
\end{bicode}
Any use of the inline \bitt{\emph{name}} in subsequent expressions is
precisely equivalent to wrapping \bitt{\emph{expression}} in parentheses and
replacing \bitt{\emph{name}} with it. Inlines may be recursively nested.

\subsection{Dimensions\label{Dimensions}}

\seealso{See also \secref{dim}{\kwref{dim}}} Dimensions are used to construct
vector\index{vector}, matrix\index{matrix} and
higher-dimensional\index{higher\,dimensional} variables. Typically they have a
spatial interpretation, for example a large 3-dimensional spatial
model\index{spatial\,model} may declare dimensions \bitt{x}, \bitt{y} and
\bitt{z}.

Dimensions are declared using:
\begin{bicode}
dim \emph{name}(\emph{size})
\end{bicode}
This declares a dimension of name \bitt{\emph{name}} and size
\bitt{\emph{size}}.

\begin{tip}
Because LibBi is primarily meant for state-space models, the time dimension is
special and not declared explicitly.
\end{tip}

\subsection{Variables\label{Variables}}

\seealso{See also \secref{input}{\kwref{input}, \kwref{noise}, \kwref{obs},
    \kwref{param} and \kwref{state}}} Variables are named and mutable
scalar\index{scalar}, vector\index{vector}, matrix\index{matrix} or
higher-dimensional\index{higher\,dimensional} objects.

A simple scalar variable is declared using:
\begin{bicode}
\emph{type} \emph{name}
\end{bicode}
where \bitt{\emph{type}} is one of:
\begin{description}
\item[\kwref{input}] for an observed variable that is set (and possibly changes
  over time) according to input from a file,
\item[\kwref{param}] for a latent variable that does not change over time,
\item[\kwref{state}] for a latent variable that changes over time,
\item[\kwref{noise}] for a latent variable that changes in time with no
  autocorrelation in time,
\item[\kwref{obs}] for an observed variable that changes over time.
\end{description}
For example, for the equation of the state-space model in the
\secref{Introduction}{Introduction}, the parameter $\theta$ may be declared
using:
\begin{bicode}
param theta
\end{bicode}
the state variable $x$ using:
\begin{bicode}
state x
\end{bicode}
and the observed variable $y$ using:
\begin{bicode}
obs y
\end{bicode}

A vector\index{vector}, matrix\index{matrix} or
higher-dimensional\index{higher\,dimensional} variable is declared by listing
the names of the \secref{Dimensions}{Dimensions} over which it should extend
in a comma-separated list enclosed in square brackets, after the variable
name. For example:
\begin{bicode}
dim m(50)
dim n(20)
...
state x[m,n]
\end{bicode}
declares a state variable \bitt{x}, which is a matrix\index{matrix} of size
$50 \times 20$ declared over the dimensions \bitt{m} and \bitt{n}.

The declaration of a variable can also include various arguments that control,
for example, whether or not it is included in output files. These are
specified in parentheses after the variable declaration, for example:
\begin{bicode}
state x[m,n](has_output = 0)
\end{bicode}

\subsection{Actions\label{Actions}}

Within each top-level block, a probability density is specified using
\emph{actions}. If \bitt{x} is some variable already declared, an action
takes the form:
\begin{bicode}
x ~ \textsl{name}(\textsl{arguments}, ...)
\end{bicode}
or
\begin{bicode}
x <- \textsl{name}(\textsl{arguments}, ...)
\end{bicode}

The first form indicates that the (random) variable \bitt{x} is distributed
according to the action given on the right. Such actions are usually, and
unsurprisingly, named after common parametric distributions (e.g.
\actionref{gaussian}, \actionref{gamma} and \actionref{uniform}).

The second form indicates that the (deterministic) variable \bitt{x} should be
assigned a value evaluated according to the action given on the right. Such
actions may require the evaluation of a simple scalar\index{scalar},
vector\index{vector} or matrix\index{matrix} expression, or may required more
complicated processing, such as the numerical integration of ordinary
differential equations\index{ordinary\,differential\,equations} (e.g. the
\actionref{ode}) action).

Actions support both \emph{named}\index{named\,arguments} and \emph{positional}
arguments\index{positional\,arguments}, and this will be indicated in their
documentation. Positional arguments are interpreted by the order given. For
example
\begin{bicode}
x ~ gaussian(0.0, 1.0)
\end{bicode}
means that \bitt{x} is distributed according to the \actionref{gaussian}
action with, by the definition of that action, mean $0.0$ and standard
deviation $1.0$.

The \actionref{gaussian} action also happens to support named arguments, so
the following is equivalent:
\begin{bicode}
x ~ gaussian(mean = 0.0, std = 1.0)
\end{bicode}
The order of named arguments is unimportant, so the following is also
equivalent:
\begin{bicode}
x ~ gaussian(std = 1.0, mean = 0.0)
\end{bicode}

Positional and named arguments may be mixed, but all positional arguments must
appear before all named arguments. Thus, this is valid:
\begin{bicode}
x ~ gaussian(0.0, std = 1.0)
\end{bicode}
but these are not:
\begin{bicode}
x ~ gaussian(mean = 0.0, 1.0)
x ~ gaussian(std = 1.0, 0.0)
\end{bicode}
This avoids ambiguity.

Refer to the definition of a particular action to determine which arguments
may be passed in positional, named or either form.

\subsection{Blocks}

Some actions are more complicated and can be wrapped in \emph{blocks}. A
good example is the \actionref{ode} action. This describes a single ordinary
differential equation\index{ordinary\,differential\,equations}, which must be
grouped with other actions that describe the other ordinary differential
equations of the same system. The grouping is achieved by the \blockref{ode}
block.

Consider the following Lotka-Volterra-type\index{Lotka-Volterra} transition
model:
\begin{bicode}
sub transition \{
  sub ode \{
    P <- ode(alpha*P - c*P*Z)
    Z <- ode(e*c*P*Z - m_l*Z)
  \}
\}
\end{bicode}
Here, the additional \blockref{ode} block combines the two actions into the
one system of ordinary differential equations.

Note that every action is automatically wrapped in an appropriate enclosing
block like this during processing. Indeed, in this case, the two
\actionref{ode} actions will be implicitly wrapped in the one \blockref{ode}
block anyway, so that explicitly doing so is unnecessary (but unharmful). Like
actions, however, blocks can take arguments; explicitly giving the enclosing
block permits arguments to be changed. In this case, the \blockref{ode} block
has parameters to configure the numerical integrator used to simulate the
differential system. These can be adjusted:
\begin{bicode}
sub transition \{
  sub ode(atoler = 1.0e-3, rtoler = 1.0e-3, alg = 'rk4') \{
    P <- ode(alpha*P - c*P*Z)
    Z <- ode(e*c*P*Z - m_l*Z)
  \}
\}
\end{bicode}

The top-level \blockref{transition} block, too, has an optional argument,
giving the time-step for discrete-time parts of the system. While not too
useful here given the continuous-time model, this argument can nevertheless be
given:
\begin{bicode}
sub transition(delta = 1.0) \{
  sub ode(atoler = 1.0e-3, rtoler = 1.0e-3, alg = 'rk4') \{
    P <- ode(alpha*P - c*P*Z)
    Z <- ode(e*c*P*Z - m_l*Z)
  \}
\}
\end{bicode}

\begin{tip}
The details of the implicit wrapping of actions by blocks should usually be
unimportant, but to see precisely what transformations are being made to the
model, use the \clientref{rewrite} command. This is particularly useful for
debugging purposes when a model is not behaving as expected.
\end{tip}

Arguments, both positional and named, work for blocks as they do for actions.

\subsection{The \bitt{do..then} clause\label{do_then}}

It is assumed that all actions within the same block are independent, and can
be evaluated concurrently. Where dependencies exist between actions, the
\bitt{do..then} clause may be used to serialise actions so
as to satisfy prerequisites:
\begin{bicode}
do \{
  eps ~ gaussian(0.0, 1.0)
\} then \{
  x <- A*x + eps
\}
\end{bicode}
Here, the variable \bitt{x} depends on the variable \bitt{eps} first being
evaluated.

Any number of \bitt{then} parts may follow the initial \bitt{do}.

Under the hood, LibBi assumes that it can evaluate actions within the same block
in parallel, unless it is told otherwise. The \bitt{do..then} clause is the
only way to tell it otherwise.

Named blocks can be used in a \bitt{do..then} clause. The \bitt{do} or
\bitt{then} keyword simply replaces the \bitt{sub} keyword, for example:
\begin{bicode}
sub transition(delta = 1.0) \{
  do \{
    alpha ~ normal(mu, sigma)
  \} then ode(atoler = 1.0e-3, rtoler = 1.0e-3, alg = 'rk4') \{
    P <- ode(alpha*P - c*P*Z)
    Z <- ode(e*c*P*Z - m_l*Z - m_q*Z*Z)
  \}
\}
\end{bicode}

\subsection{Expressions\label{Expressions}}

LibBi supports expressions over scalars, vectors and matrices, as well as the
special type \textit{element}, which requires some explanation. These are
defined as follows:
\begin{itemize}
\item a \textit{scalar}\index{scalar} is a literal, constant or variable that
  is not declared over any dimensions,
\item a \textit{vector}\index{vector} is a variable declared over
  exactly one dimension,
\item a \textit{matrix}\index{matrix} is a variable declared over exactly two
  dimensions,
\item variables declared over three or more dimensions are not given a special
  name,
\item an \textit{element} is a reference to a single element of any
  variable declared over one or more dimensions.
\end{itemize}

The particular distinction of the element type in LibBi will be unfamiliar to
most users. Syntactically, whenever square brackets are used to refer to a
single element of a variable (e.g. \bitt{a[i]}), that symbol is of the
element type.

There are a few implications of these definitions that may not be immediately
obvious (or intuitive):
\begin{itemize}
\item A variable declared over a single dimension of size one is considered a
  vector, not a scalar. Any variable declared over more than one dimension,
  where all of those dimensions have size one, is likewise not considered a
  scalar. The reason for this is that the particular boundary conditions of
  its dimensions may convey different behaviour to that of a scalar.

\item An element, despite referring to a single value, is not a scalar! In
  binary operations, elements may be paired with scalars, but not with vectors
  or matrices. Scalars, on the other hand, may be paired with vectors and
  matrices. The element syntax is, essentially, a concise means of describing
  element-wise transformation kernels (element
  expressions\index{element\,expression}) that are readily performed in
  parallel.

\end{itemize}

Special classes of expression are:
\begin{itemize}
\item A \textit{constant expression}\index{constant\,expression} is one that
  can be evaluated at compile-time. It must be scalar, and may refer to
  literals, constants and inlines that expand to other constant expressions
  only.
\item A \textit{static expression}\index{static\,expression} is one that does
  not depend on time. It may refer to literals, constants, variables of type
  \kwref{param}, and inlines that expand to other static expressions only.
\item A \textit{common expression}\index{common\,expression} is one that does
  not depend on the state of a particular trajectory. It may refer to
  literals, constants, variables of type \kwref{param} or \kwref{input}, and
  inlines that expand to other common expressions only.
\item An \textit{element expression}\index{element\,expression} is one that
  references at least one element. It may refer to literals, constants,
  scalars and elements only.
\end{itemize}
Note that a constant expression is a static expression, and a static
expression is a common expression.

Element expressions\index{element\,expression} are used for more complicated
computations that cannot be expressed in matrix\index{matrix} form, or that
when expressed as such become contrived.  They are appropriate when each
element of the target variable can be expressed as a function of scalars
and/or the elements of other variables.

Consider the following example describing a Lorenz 96 model:
\begin{bicode}
dim x(size = 20, boundary = 'cyclic')
param F
state X[x]
\(\ldots\)
X[i] <- ode(X[i - 1]*(X[i + 1] - X[i - 2]) - X[i] + F)
\end{bicode}

Here, \bitt{X} is a vector variable declared along the \bitt{x}
dimension. The final line is an \actionref{ode}
action giving the derivative of the \bitt{i}th element of \bitt{X}. The
presence of the element syntax \bitt{X[i]} is what makes this an element
expression.

The \textit{alias} \bitt{i} on the left-hand side is an arbitrary name for
indexing along the dimension of \bitt{X}. Note the way in which \bitt{i}
is used on the right-hand side to refer to other elements of the \bitt{X}
vector. Indexing expressions that appear between square brackets, such as
\bitt{[i + 1]}, \bitt{[i - 2]} and \bitt{[i]} above must be constant
expressions\index{constant\,expression}. Note that, in this particular case,
any such expressions that evaluate to outside the bounds of \bitt{X} will
wrap around to the start or end of the vector, as the \bitt{x} dimension is
declared with \bitt{boundary = 'cyclic'}.

Consider another example:
\begin{bicode}
dim m(20)
state D[m,m], x[m], y[m]
\(\ldots\)
D[i,j] <- sqrt(pow(x[i] - x[j], 2) - pow(y[i] - y[j], 2))
\end{bicode}

This computes the Euclidean distance
matrix\index{matrix}\index{distance\,matrix} \bitt{D} between several points
with coordinates given in the vectors\index{vector} \bitt{x} and
\bitt{y}. This demonstrates how multiple indices, in this case \bitt{i} and
\bitt{j}, may be used. The particular selection of \bitt{i} and \bitt{j} is
again arbitrary; any name may be used.

Element expressions\index{element\,expression} may use any
scalar\index{scalar} operators and functions. All operands and arguments must
be scalars or elements. Thus the following is not permitted:
\begin{bicode}
d[i] <- dot(x, y)
\end{bicode}
as \actionref{dot} is a vector action. One might consider expressing the same
as:
\begin{bicode}
do \{
  c <- dot(x,y)
\} then \{
  d[i] <- c
\}
\end{bicode}
where the dot product is first stored in the scalar variable \bitt{c}, and
then copied into each element of the vector \bitt{d}.

\subsection{Operators\label{Operators}}

The following operators are supported in expressions:

\noindent
\begin{tabular}{lr}
\hline
Scalar/vector/matrix arithmetic operators: & \bitt{+ - * / \% \^{}} \\
Element-wise vector/matrix operators:  & \bitt{.+ .- .* ./ .\% .\^{}} \\
Bitshift operators: & \bitt{<< >>} \\
Comparison operators: & \bitt{== != < <= > >= } \\
Logical operators: & \bitt{\&\& ||} \\
Ternary operators: & \bitt{?:} \\
\hline
\end{tabular}\index{scalar}\index{vector}\index{matrix}\index{arithmetic}\index{operators}

\subsection{Functions\label{Functions}}

The following functions are supported in expressions:

\noindent
\begin{tabular}{p{\textwidth}}
\hline
\bitt{abs log nanlog exp nanexp max min sqrt pow mod ceil floor gamma lgamma
  sin cos tan asin acos atan atan2 sinh cosh tanh asinh acosh atanh} \\
\hline
\end{tabular}\index{functions}

\section{Data\label{Data}}\index{data}\index{I/O}

Data\index{data} is input to and output from\index{I/O} LibBi using
NetCDF\index{NetCDF} files. The structure of such files is specified here.

\subsection{Input files}

Input files take three forms:
\begin{itemize}
\item initialisation files, containing the initial values of \kwref{state}
  variables,
\item input files, containing the values of \kwref{input} variables, possibly
  changing across time, and
\item observation files, containing the observed values of \kwref{obs}
  variables.
\end{itemize}
All of these use the same structure. That structure is quite flexible,
allowing for the representation of both dense and sparse input. Sparsity may
be in time or space. An example of the former is, in a discrete-time model,
having a scalar \kwref{obs} variable that is not necessarily observed at all
time steps. An example of the latter is, again in a discrete-time model,
having a vector \kwref{obs} variable for which not all elements are necessarily
observed at all time steps.

Each variable in the NetCDF file is associated with the variable of the same
name in the model specification. Extraneous variables in the NetCDF file are
ignored. Variables in the model specification which cannot be matched to a
variable in the NetCDF file do not receive input from it.

Each variable in the NetCDF file may be defined along the following
dimensions, in the order given:
\begin{enumerate}
\item Optionally, a dimension named \bitt{ns}, used to index multiple
  experiments set up in the same file. If not given for a variable, that
  variable is assumed to be the same for all experiments.
\item Optionally, a time dimension (see below).
\item Optionally, a number of dimensions with names matching those given in
  the model specification.
\item Optionally, a dimension named \bitt{np}, used to index multiple
  trajectories (or samples, or particles) of a variable. If not given for a
  variable, the value of that variable is assumed to be the same for all
  trajectories. Variables of type \kwref{param}, \kwref{input} and \kwref{obs}
  may not use an \bitt{np} dimension, as by their nature they are meant to be
  in common across all trajectories.
\end{enumerate}

A variable given in the model specification may be represented either
\emph{densely} or \emph{sparsely} across those dimensions. For a dense
representation, use dimensions as in item 3 above. For a sparse
representation, see \secref{Coordinate_variables}{Coordinate variables}.

\subsubsection{Time variables\label{Time_variables}}

\emph{Time variables} are used to index time in a file. Each variable in the
NetCDF file with a name beginning with ``time'' is assumed to be a time
variable. Each such variable may be defined along the following dimensions, in
the order given:
\begin{enumerate}
\item Optionally, the \bitt{ns} dimension.
\item An arbitrarily named dimension.
\end{enumerate}
The latter dimension becomes a \emph{time
  dimension}\index{time\,dimension}. The time variable gives the time
associated with each index of the time dimension, a sequence which must be
monotonically non-decreasing. Other variables defined along the same time
dimension become associated with the time variable. The time dimension thus
indexes both the times at which these variables change, and the values that
they assume. A variable may only be associated with one time dimension, and
\texttt{param} variables may not be associated with one at all. If a variable
is not defined across a time dimension, it is assumed to have the same value
at all times.

Time variables and time dimensions are interpreted slightly differently for
each of the input file types:
\begin{enumerate}
\item For an initialisation file, the starting time (given by the \bitt{-t}
  command-line option, see \clientref{simulate}) is looked-up in each time
  variable, and the corresponding record in each associated variable is used
  for its initialisation.
\item For input files, a time variable gives the times at which each
  associated variable changes in value. Each variable maintains its new
  value until the time of the next change.
\item For observation files, a time variable gives the times at which each
  associated variable is observed. The value of each variable is interpreted
  as being its value at that precise instant in time.
\end{enumerate}

\begin{example}
\noindent \textbf{Representing a scalar input}

Assume that we have an \kwref{obs} variable named \bitt{y}, and we wish to
construct an observation file containing our data set, which consists of
observations of \bitt{y} at various times. A valid structure would be to
create a NetCDF file with:
\begin{itemize}
\item a dimension named \bitt{nr}, to be our time dimension,
\item a variable named \bitt{time\_y}, defined along the dimension \bitt{nr},
  to be our time variable, and
\item a variable named \bitt{y}, defined along the dimension \bitt{nr}, to
  contain the observations.
\end{itemize}
We would then fill the variable \bitt{time\_y} with the observation times of
our data set, and \bitt{y} with the actual observations. It may look something
like this:

\begin{cmdcode}
time_y[nr]    y[nr]
       0.0     6.75
       1.0     4.56
       2.0     9.45
       5.5     4.23
       6.0     7.12
       9.5     5.23
\end{cmdcode}

\end{example}

\begin{example}
\noindent \textbf{Representing a vector input, densely}

Assume that we have an \kwref{obs} variable named \bitt{y}, which is a vector
defined across a dimension of size three called \bitt{n}. We wish to construct
an observation file containing a our data set, which consists of observations
of \bitt{y} at various times, where at each time all three elements of
\bitt{y} are observed. A valid structure would be to create a NetCDF file
with:
\begin{itemize}
\item a dimension named \bitt{nr}, to be our time dimension,
\item a variable named \bitt{time\_y}, defined along the dimension \bitt{nr},
  to be our time variable,
\item a dimension named \bitt{n}, and
\item a variable named \bitt{y}, defined along the dimensions \bitt{nr} and
  \bitt{n}, to contain the observations.
\end{itemize}
We would then fill the variable \bitt{time\_y} with the observation times of
our data set, and \bitt{y} with the actual observations. It may look something
like this:

\begin{cmdcode}
time_y[nr]     y[nr,n]
       0.0     6.75 3.34 3.45
       1.0     4.56 4.54 1.34
       2.0     9.45 3.43 1.65
       5.5     4.23 8.65 4.64
       6.0     7.12 4.56 3.53
       9.5     5.23 3.45 3.24
\end{cmdcode}

\end{example}

\subsubsection{Coordinate variables\label{Coordinate_variables}}

\emph{Coordinate variables} are used for sparse indexing of model dimensions
in a file. Each variable with a name beginning with ``coord'' is assumed to be
a coordinate variable. Each such variable may be defined along the following
dimensions, in the order given:
\begin{enumerate}
\item Optionally, the \bitt{ns} dimension.
\item A time dimension or some other arbitrary dimension.
\item Optionally, some arbitrary dimension.
\end{enumerate}
The second dimension becomes a \emph{coordinate
  dimension}\index{coordinate\,dimension}, which may also be a time
dimension. Other variables defined along the same coordinate dimension become
associated with the coordinate variable. The coordinate variable gives the
coordinate associated with each index along the coordinate dimension. The last
dimension, if any, should have a length equal to the number of dimensions
across which those other variables are defined. So, for example, if these
variables are matrices, the last dimension should have a length of two. If the
variables are vectors, so that they have only one dimension, the coordinate
variable need not have this last dimension.

%If a multidimensional variable is associated with a coordinate variable with
%fewer components than the number of dimensions along which it is defined,
%these are assumed to index the outermost dimensions. That is, a variable may
%be sparse in some dimensions and dense in others, but the sparse dimensions
%must be the outermost.

If a variable specified across one or more dimensions in the model cannot be
associated with a coordinate variable, then it is assumed to be represented
densely.

\begin{example}
\noindent \textbf{Representing a vector input, sparsely}

Assume that we have an \kwref{obs} variable named \bitt{y}, which is a vector
defined across a dimension of size three called \bitt{n}. We wish to construct
an observation file containing our data set, which consists of observations of
\bitt{y} at various times, where at each time only a subset of the elements of
\bitt{y} are observed. A valid structure would be to create a NetCDF file
with:
\begin{itemize}
\item a dimension named \bitt{nr}, to be our time dimension,
\item a variable named \bitt{time\_y}, defined along the dimension \bitt{nr},
  to be our time variable,
\item a variable named \bitt{coord\_y}, defined along the dimension \bitt{nr},
  to be out coordinate variable,
\item a variable named \bitt{y}, defined along the dimension \bitt{nr}, to
  contain the observations.
\end{itemize}
We would then fill the variable \bitt{time\_y} with the observation times of
our data set, \bitt{coord\_y} with the coordinate of each observation, and
\bitt{y} with the observations themselves. It may look something like this:

\begin{cmdcode}
time_y[nr]    coord_y[nr]    y[nr,n]
       0.0             0       6.75
       0.0             1       3.34
       1.0             0       4.56
       1.0             1       4.54
       1.0             2       1.34
       2.0             1       3.43
       5.5             3       4.64
       6.0             0       4.23
       6.0             2       3.53
       9.5             1       3.45
\end{cmdcode}

Note that, if \bitt{y} had $m > 1$ dimensions, the \bitt{coord\_y}
variable would be defined along some additional, arbitrarily named dimension
of size $m$ in the NetCDF file, and the values of \bitt{coord\_y} in the above
table would be vectors.
\end{example}

\subsection{Simulating models with input\label{Simulating_models_with_input}}

The precise way in which input files and the model specification interact is
best demonstrated in the steps taken to simulate a model. Computing densities
is similar. The \emph{initialisation file} referred to in the proceeding steps
is that given by the \bitt{--init-file} command-line option, and the
\emph{input file} that given by \bitt{--input-file}.
\begin{enumerate}
\item Any \kwref{input} variables in the input file that are not associated with
  a time variable are initialised by reading from the file.
\item The \blockref{parameter} top-level block is sampled.
\item Any \kwref{param} variables in the input file are overwritten by reading
  from the file.
\item Any static expressions extracted for precomputation are evaluated.
\item The \blockref{initial} top-level block is sampled.
\item Any \kwref{state} variables in the input file are overwritten by reading
  from the file.
\item The \blockref{transition} top-level block is sampled forward through
  time. Sampling stops at each time that an \kwref{input} variable is to
  change, according to the input file, at which point the \kwref{input}
  variable is updated and sampling of the \blockref{transition} block
  continues. Continuous-time\index{continuous\,time} components of the
  \blockref{transition} block (e.g. \actionref{ode} actions) are always
  actioned. The remaining, discrete-time\index{discrete\,time} components, are
  only actioned when the current time is an integer multiple of the time step
  given by the \blockref{transition} block's \bitt{delta} argument.
\end{enumerate}

Note two important points in this procedure:
\begin{itemize}
\item An \kwref{input} variable in the input file that is not associated with a
  time variable is initialised before anything else, whereas an \kwref{input}
  variable that is associated with a time variable is not initialised until
  simulation begins, even if the first entry of that variable indicates an
  update at time zero.
\item While the \blockref{parameter} and \blockref{initial} blocks are
  sampled, the samples may be later overwritten from the initialisation
  file. Thus, the initialisation file need not contain a complete set of
  variables in order to ensure that all variables are initialised before
  simulation proceeds. This also ensures
  \secref{Pseudorandom_reproducibility}{pseudorandom reproducibility}
  regardless of the presence, or content, of the initialisation file.
\end{itemize}

\subsection{Output files}

\section{Command-line interface\label{Command_line_interface}}\index{command\,line}

Methods are applied to models via the command line interface of LibBi. Invoke LibBi
via the command line as:
\begin{cmdcode}
bi \textit{command} \textit{options} ...
\end{cmdcode}
where \bitt{\textit{command}} is any one of the following:
\begin{description}
\item[\clientref{simulate}] to simulate trajectories
  from a model,
\item[\clientref{filter}] for filtering problems using the
  model and observations,
\item[\clientref{smooth}] for smoothing problems using the
  model and observations,
\item[\clientref{optimise}] for parameter optimisation
  problems using the model and observations,
\item[\clientref{sample}] for parameter sampling
  problems using the model and observations,
\item[\clientref{draw}] to visualise a model (useful for
  debugging and development),
\item[\clientref{rewrite}] to process a model and
  output a new model after applying internal transformations and optimisations
  (useful for debugging and development),
\end{description}
and available \bitt{\textit{options}} depend on the command.

Options may be specified in a configuration file\index{config\,file} or on the
command line itself. To use a configuration file, give the name of the file on
the command line, preceded by \bitt{@}, e.g.
\begin{cmdcode}
bi \textit{command} @command.conf
\end{cmdcode}

More than one config file may be specified, each preceded by \bitt{@}. An
option given on the command line will override an option of the same name
given in the configuration file.

A config file simply contains a list of command-line options just as they
would be given on the command line itself. For readability, the command-line
options may be spread over any number of lines, and end-of-line comments,
preceded by \bitt{\#}, may appear. The contents of one config file may be
nested in another by using the \bitt{@file.conf} syntax within that
other. This can be useful in avoiding redundancy. For example, the
\clientref{filter} command inherits all the options of \clientref{simulate},
and the \clientref{sample} command inherits all the options of
\clientref{filter}. In this case it may be useful to write a
\bitt{simulate.conf} file that is nested within a \bitt{filter.conf} file,
that is nested within a \bitt{sample.conf} file, so that the config files
inherit options just as the commands do.

\section{Performance guide\label{Performance guide}\index{performance}}

One of the aims of LibBi is to alleviate you, the user, from performance
considerations. Consequently, there is little scope in the modelling language
for performance tuning, but little need either. Where you have some control is
in compilation and I/O.

LibBi will do the following for you:
\begin{itemize}
\item Precompute constant subexpressions.
\item Precompute static subexpressions in the transition and observation
  models.
\end{itemize}

Reducing redundant or repetitious computations is thus unnecessary where these
are constant or static subexpressions. For example, taking the square-root of
a variance parameter need not be of concern:
\begin{bicode}
param sigma2
\(\ldots\)
sub transition \{
    epsilon ~ gaussian(mu, sqrt(sigma2))
    \(\ldots\)
\}
\end{bicode}
Here, \bitt{sqrt(sigma2)} will be extracted and precomputed outside of the
transition model -- \bitt{sigma2} is a parameter, and so
\bitt{sqrt(sigma2)} a static expression.

Use the \clientref{rewrite} command if you wish to inspect the transformations
made to a model.

The following I/O and configuration issues are worth considering:
\begin{itemize}
\item When declaring a variable, use a \bitt{has\_output = 0} argument to omit
  it from output files if it will not be of interest.

\item LibBi includes a great deal of in-code assertion
  checking\index{assertion\,checking} to help ensure valid code
  generation. These assertion checks are enabled by default, and it is
  recommended that they remain so for test runs. Significant performance gains
  can be realised by disabling these assertion checks with the
  \bitt{--disable-assert} command-line option, and this is recommended for
  production runs.

\item \marginlabel{GPU} Experiment with the \bitt{--enable-cuda} command-line
  option to make use of a CUDA-enabled GPU\index{GPU}. This will usually
  improve performance when a sufficient number of model trajectories are to be
  simulated.

\item \marginlabel{SSE} Experiment with the \bitt{--enable-sse} command-line
  option to make use of CPU SSE instructions\index{SSE}\index{SIMD}. These can
  provide up to a two-fold (double precision) or four-fold (single precision)
  speed-up.

\item \marginlabel{Multicore}\index{multithreading}\index{OpenMP} Experiment
  with the \bitt{--threads} command-line option to set the number of CPU
  threads. Typically there are depreciating returns as the number of threads
  is increased, and beyond the number of CPU cores available performance will
  be particularly poor. For CPUs with hyperthreading enabled, it is
  recommended that the number of threads is no more than the number of
  physical CPU cores, which may be half the default number of threads.

\item \marginlabel{Single precision} Experiment with using
  single precision\index{single\,precision} by using the \bitt{--enable-single}
  command-line option. Assuming numerical error is tolerable, this can offer
  significant performance improvements, especially when used in combination
  with the \bitt{--enable-cuda} or \bitt{--enable-sse} options.

\item Use optimised versions of libraries, especially the BLAS\index{BLAS} and
  LAPACK\index{LAPACK} libraries.

\item Use the Intel C++ compiler\index{Intel\,compiler} if
  available. Anecdotally, this tends to produce code that runs 10-20\% faster
  than \bitt{gcc}\index{gcc}. The \bitt{configure} scripts for both LibBi and
  client programs should automatically detect the Intel C++
  compiler\index{compiler}, and use it if available.

\end{itemize}

\section{Style guide\label{Style_guide}}\index{style\,guide}

The following naming conventions are recommended:
\begin{itemize}
\item Model names are CamelCase, the first letter always capitalised.
\item Action and block names are all lowercase, with multiple words separated
  by '\_' (the underscore).
\item Dimension and variable names should be consistent, where possible, with
  their counterparts in a description of the model as it might appear in a
  scientific paper. For example, single upper-case letters for the names of
  matrix\index{matrix} variables are appropriate, and standard symbols (rather
  than descriptive names) are encouraged. Greek letters should be written out
  in full, the first letter capitalised for the capital version
  (e.g. \bitt{gamma} and \bitt{Gamma}).
\item Comments should be used liberally, with descriptions provided for all
  dimensions and variables in particular. Consider including units as part of
  the description, where relevant.
\item Names ending in '\_' (the underscore) are intended for internal use
  only, and so no such names should generally appear in a model specification.
\item Indent using two spaces, and do not use tabs.\index{indenting}
\end{itemize}
