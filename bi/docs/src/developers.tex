\section{Introduction}

LibBi consists of a few different components:
\begin{itemize}
\item A \emph{library} which provides classes and functions for simulation,
  filtering, smoothing, optimising and sampling from state-space models, as
  well as auxiliary functionality such as memory management, I/O, numerical
  computing etc. It is written in C++ using a generic programming paradigm.
\item A \emph{code generator} which parses the LibBi modelling language,
  contructs and optimises an internal model representation, and generates C++
  code for compilation against the library. In addition it generates a GNU
  Autotools build system and various client programs for common tasks.
\item A \emph{command-line interface} which hides the code generation,
  compilation and linking procedures behind a simple interface for users.
\item Packages for common statistical software, such as \emph{OctBi} for GNU
  Octave and \emph{RBi} for R, that allow querying, collation and
  visualisation of results output by LibBi.
\end{itemize}.

Developing LibBi involves adding or modifying functionality in one or more of
its major \hyperref[hyper][Components]{components}. A typical exercise is
adding block and action types to the code generator to introduce new features,
such as support for additional probability density functions. This may also
involve implementing new functionality in the library that these blocks and
actions can use. Another common task is adding a new inference method to the
library, then adding or modifying the code generator to produce the client
code that will use this.

\section{Setting up a development environment}

When developing LibBi, it is recommended that you do not install it in the
usual manner as a system-wide Perl module. The recommended approach is to set
up a local directory with the LibBi files in such a way that modifications to
these files take effect immediately.

\subsection{Obtaining the source code}

Bi is available via Subversion at
\hyperref[hyper][https://svnserv.csiro.au/svn/css/modelling/bgc/code/bi]{https://svnserv.csiro.au/svn/css/modelling/bgc/code/bi}. You
would typically check out a working copy of the \bitt{trunk} directory:
\begin{cmdcode}
svn co https://svnserv.csiro.au/svn/css/modelling/bgc/code/bi/trunk
\end{cmdcode}

For any endeavours that may temporarily break functionality, working on a
branch, rather than the main trunk, is essential. A branch can be created by
copying the trunk into an appropriately named subdirectory of the
\bitt{branches} directory:
\begin{cmdcode}
svn copy -m 'Created branch for...' \textbackslash
  https://svnserv.csiro.au/svn/css/modelling/bgc/code/bi/trunk \textbackslash
  https://svnserv.csiro.au/svn/css/modelling/bgc/code/bi/branches/branch_name
\end{cmdcode}
and then checking out a working copy of the branch instead. While the trunk
should contain a working version of Bi at all times, branches need
not. Regular commits to branches are thus encouraged, even of unfinished code
or code that does not yet compile and run correctly. Note that you may like to
copy only a particular subdirectory of the trunk into a branch, rather than
the whole directory.

Once modifications are complete, a branch can be merged back into a working
copy of the trunk:
\begin{cmdcode}
svn merge --reintegrate \textbackslash
  https://svnserv.csiro.au/svn/css/modelling/bgc/code/bi/branches/branch_name
\end{cmdcode}
and then the working copy of the trunk committed.

\subsection{Using Eclipse\label{Using_Eclipse}}

LibBi is set up to use the Eclipse IDE. From a vanilla install of the Eclipse
IDE for C/C++ (available at
\hyperref[hyper][http://www.eclipse.org]{http://www.eclipse.org}), a number of
additional plugins are supported, and recommended. These are, along with the
URLs of their update sites:
\begin{itemize}
\item Subclipse (Subversion integration)
  \hyperref[hyper][http://subclipse.tigris.org/update]{http://subclipse.tigris.org/update\_1.8.x}
  (change 1.8 to match your Subversion version)

\item Eclox (Doxygen integration) \hyperref[hyper][http://download.gna.org/eclox/update]{http://download.gna.org/eclox/update}

\item EPIC (Perl integration) \hyperref[hyper][http://e-p-i-c.sf.net/updates/testing]{http://e-p-i-c.sf.net/updates/testing}

\item Perl Template Toolkit Editor \hyperref[hyper][http://perleclipse.com/TTEditor/UpdateSite]{http://perleclipse.com/TTEditor/UpdateSite}
\end{itemize}
They may be installed via the \textsf{Help > Install New Software...} menu
item in Eclipse, in each case entering the update site URL.

With Subclipse installed, Bi may be checked out of the Subversion repository
as a separate project in Eclipse. Use the \textsf{File > New > Other...} menu
item and select the \textsf{SVN > Checkout Projects from SVN} item from the
list. Enter the URL of the Bi Subversion repository trunk (or of a branch),
then select one or more of the subdirectories to check these out as Eclipse
projects.

\marginlabel{Code style file}
\index{style guide} A custom code style is available in the
\bitt{custom\_code\_style.xml} file, and should be used. This may be loaded
via the \textsf{Window > Preferences} dialog, using the \textsf{Import...}
button under \textsf{C/C++ > Code Style}.

\subsection{Using another development environment}

It is not necessary to use Eclipse to develop LibBi. Any text editor will
do. You are asked, however, to pay particular attention to maintaining the
appropriate coding style, particularly with regard to indenting.

%%%%
\section{Developing the code generator}

The code generator component is implemented in Perl using an object-oriented
paradigm, with extensive use of the Perl Template Toolkit (TT) for producing
C++ source and other files.

\subsection{Actions and blocks}

A user of LibBi is exposed only to those blocks and actions which they
explicitly write in their model specification file. Developers must be aware
that beyond these \textit{explicit} blocks, additional \textit{implicit}
blocks are inserted according to the actions specified by the user. In
particular, each action has a preferred parent block type. If the user, in
writing their model specification, does not explicitly place an action within
its preferred block type, the action will be implicitly wrapped in it anyway.

For example, take the model specification:
\begin{bicode}
sub transition \{
  do \{
    x <- a*x + b
    y <- c*y + d
  \} then \{
    x ~ uniform(x - 1.0, x + 1.0)
    y ~ gaussian(y, 1.0)
  \}
\}
\end{bicode}
The \actionref{uniform} and \actionref{gaussian} actions prefer different
parent block types. These additional block types will be inserted, to give the
equivalent of the user having specified:
\begin{bicode}
sub transition \{
  do \{
    x <- a*x + b
    y <- c*y + d
  \} then \{
    sub uniform_ \{
      x ~ uniform(x - 1.0, x + 1.0)
    \}
    sub gaussian_ \{
      y ~ gaussian(y, 1.0)
    \}
  \}  
\}
\end{bicode}

For the developer, then, actions and blocks are always written in tandem.
Note the underscore suffix on \bitt{uniform\_} and \bitt{gaussian\_} is a
convention that marks these as blocks for internal use only -- the user is not
intended to use them explicitly (see the \secref{Style_guide}{style guide}).

It is worth familiarising yourself with this behaviour, and other
transformations made to a model, by using the \clientref{rewrite} command.

To add a block:
\begin{enumerate}
\item Choose a name for the block.
\item Create a Perl module \bitt{Bi::Block::\textit{name}} in the
  file \bitt{gen/src/Bi/Block/\textit{name}.pm}. Note that Perl module
  ``CamelCase'' naming conventions should be ignored in favour of Bi block
  naming conventions here.
\item Create a new TT template
  \bitt{gen/src/tt/block/\textit{name}.hpp.tt}. When rendered, the template
  will be passed a single variable named \bitt{block}, which is an object of
  the class created in the previous step.
\end{enumerate}

As implementation details of the Perl module and template are subject to
change, it is highly recommended that you copy and modify an existing, similar
block type, as the basis for your new block type.

To add an action:
\begin{enumerate}
\item Choose a name for the action.
\item Create a Perl module \bitt{Bi::Action::\textit{name}} in the
  file \bitt{gen/src/Bi/Action/\textit{name}.pm}. Note that Perl module
  ``CamelCase'' naming conventions should be ignored in favour of Bi action
  naming conventions here.
\item If necessary, create a new TT template
  \bitt{gen/src/tt/action/\textit{name}.hpp.tt}. During rendering, the
  template will be passed a single variable named \bitt{action}, which is an
  object of the class created in the previous step. This template is not
  required; the template of the containing block may generate all the
  necessary code.
\end{enumerate}

\subsection{Clients}

To add a client:
\begin{enumerate}
\item Consider whether an existing client can be modified or a new client
  should be added. For an existing client, edit the corresponding Perl module
  \bitt{src/Bi/Client/\textit{name}.pm}. For a new client, choose a name
  and create a new Perl module \bitt{src/Bi/Client/\textit{name}.pm}. Again,
  Bi client naming conventions should be favoured over Perl module naming
  conventions.
\item Consider whether an existing template can be modified or a new template
  should be created. For an existing template, edit the corresponding template
  in \bitt{tt/cpp/client/\textit{template}.cpp.tt}. For a new template:
\begin{enumerate}
\item Create files \bitt{tt/cpp/client/\textit{template}.cpp.tt} and
  \bitt{tt/cpp/client/\textit{template}.cu.tt}. Note that the second
  typically only needs to \bitt{\#include} the former, the \bitt{*.cu}
  file extension is merely needed for a CUDA-enabled compile.
\item Modify the Perl module to select this template for use where
  appropriate.
\item Add the template name to the list given at the top of
  \bitt{tt/build/Makefile.am.tt} to ensure that a build fule is generated
  for it.
\end{enumerate}
\end{enumerate}

\subsection{Designing an extension\label{Designing_an_extension}}

Given that there are no particular requirements on actions other than those
imposed by your own containing block class, there is considerable flexibility
in designing block and action behaviour. This section provides some guidance
as to best practice.

It is recommended that most logic is written in blocks, rather than
actions. This allows multiple actions to be combined where doing so will
improve performance (e.g. minimising the number of kernel launches on a GPU
device, and maximising parallelism). Note that, unless otherwise specified,
arguments to an action are unrolled and evaluated prior to any calls to the
action and its containing block. All arguments are thus passed as the
variables holding the evaluated result.

Complex C++ code should form part of the library, rather than being included
in TT templates. The C++ code generated by templates should typically be
limited to arranging for a few function calls into LibBi, where most of the
work will be done.

When writing templates for client programs, consider that it is advantageous
for the user that they can change command line arguments without the C++ code
changing, and thus triggering a recompile. This can be achieved by writing
runtime checks on command-line options in C++ rather than code generation-time
checks in TT templates. This need not be taken to the extreme, however: clear
and simple template code is preferred over convoluted C++!

\subsection{Documenting an extension\label{Documenting_an_extension}}

Reference documentation for actions, blocks and clients is written in the Perl
module created for them, in standard Perl POD. Likewise, parameters for
actions and blocks, and command-line options for clients, are enumerated in
these. The idea of this is to keep implementation and documentation together.

POD documentation in these modules is automatically converted to LaTeX and
incorporated in the \hyperref[hyper][Reference]{Reference} section of this
manual.

\subsection{Style guide\label{Developer_style_guide}}\index{style guide}

Further to the \hyperref[hyper][Style_guide]{Style guide} for users, the
following additional recommended pertain to developers:
\begin{itemize}
\item Action, block, client and argument names are all lowercase, with
  multiple words separated by '\_' (the underscore). Uppercase may be used in
  exceptional cases where this convention becomes contrived. A good example is
  matrix arguments, which might naturally be named with uppercase letters.
\item Actions, blocks and arguments that are not meant to be used explicitly
  should be suffixed with a single underscore.
\end{itemize}

\section{Developing the library}

The library component is implemented in C++ using a generic programming
paradigm. While classes and objects are used extensively, it is not
object-oriented \textsl{per se}. In particular:
\begin{itemize}
\item Class inheritance is used for convenience of implementation, not
  necessarily to represent ``is a'' relationships.
\item Polymorphism is seldom, if ever, employed.
\item Static dispatch is favoured strongly over dynamic dispatch for
  reasons related to performance. Virtual functions are not used.
\end{itemize}

\subsection{Header files}

Header files are given two extensions in LibBi:
\begin{enumerate}
\item \bitt{*.hpp} headers may be safely included in any C++ (e.g.
\bitt{*.cpp}) or CUDA (\bitt{*.cu}) source files,
\item \bitt{*.cuh} headers may only be safely included in CUDA (\bitt{*.cu})
source files. They include CUDA C extensions.
\end{enumerate}

Note that not all \bitt{*.hpp} headers can be safely included in \bitt{*.cu}
files either, due to CUDA compiler limitations, particularly those headers
that further include Boost headers which make extensive use of
templates. Efforts have been made to quarantine such incidences from the CUDA
compiler, but mileage may vary.

\subsection{Pseudorandom reproducibility\label{Pseudorandom_reproducibility}}\index{pseudorandom numbers}

It is important to maintain reproducibility of results under the same random
number seed\index{random number seed}, typically passed using the
\bitt{--seed} option on the command line. Real time impacts should be
considered, such as favouring static scheduling\index{static scheduling} over
dynamic scheduling\index{dynamic scheduling} for OpenMP\index{OpenMP} thread
blocks. Consider the following:
\begin{cppcode}
Random rng;

#pragma omp parallel for
for (int i = 0; i < N; ++i) \{
  x = rng.uniform();
  \(\ldots\)
\}
\end{cppcode}

\bitt{Random} maintains a separate pseudorandom number
generator\index{pseudorandom number generation} for each OpenMP thread. If
dynamically scheduled, the above loop gives no guarantees as to the number of
variates drawn from each generator, so that reproducibility of results for a
given seed is not guaranteed. Static scheduling should be enforced in this
case to ensure reproducibility:
\begin{cppcode}
Random rng;

#pragma omp parallel for schedule(static)
for (int i = 0; i < N; ++i) \{
  x = rng.uniform();
  \(\ldots\)
\}
\end{cppcode}

A more subtle consideration is the conditional generation of
variates. Consider the following code, evaluating a
Metropolis-Hastings\index{Metropolis-Hastings} acceptance criterion:
\begin{cppcode}
alpha = (l1*p1*q2)/(l2*p2*q1);
if (alpha >= 1.0 || rng.uniform() < alpha) \{
  accept();
\} else \{
  reject();
\}
\end{cppcode}
Here, \bitt{rng.uniform()} is called only when \bitt{alpha >= 1.0} (given
operator short-circuiting). We might prefer, however, that across multiple
runs with the same seed, the pseudorandom number generator is always in the
same state for the $n$th iteration, regardless of the acceptance criteria
across the preceding iterations. Moving the variate generation outside the
conditional will fix this:
\begin{cppcode}
alpha = (l1*p1*q2)/(l2*p2*q1);
u = rng.uniform();
if (alpha >= 1.0 || u < alpha) \{
  accept();
\} else \{
  reject();
\}
\end{cppcode}

\subsection{Shallow copy, deep assignment}

Typically, classes in LibBi follow a ``shallow copy, deep assignment''
idiom. The idiom is most apparent in the case of vector and matrix types. A
copy of a vector or matrix object is shallow -- the new object merely contains
a pointer to the memory buffer underlying the existing object. An assignment
of a vector or matrix is deep, however -- the contents of the memory buffer
underlying the existing object is copied into that of the new object.

Often the default copy constructor is sufficient to achieve a shallow copy,
while an override of the default assignment operator may be necessary to
achieve deep assignment.

\emph{Generic} copy constructors and assignment operators are also
common. These are templated overloads of the default versions which accept, as
arguments, objects of some class other than the containing class. When a
generic copy constructor or assignment operator is used, the default copy
constructor or assignment operator should always be overridden also.

\subsection{Coding conventions}

The following names are used for template parameters (where \bitt{n} is an
integer):
\begin{itemize}
\item \bitt{B} for the model type,
\item \bitt{Tn} for scalar types,
\item \bitt{Vn} for matrix types,
\item \bitt{Mn} for vector types,
\item \bitt{Qn} for pdf types,
\item \bitt{S} for type lists,
\item \bitt{L} for location (host or device),
\item \bitt{CL} for location of a cache,
\item \bitt{PX} for parents type,
\item \bitt{CX} for coordinates type,
\item \bitt{OX} for output type.
\end{itemize}

\subsection{Style guide}

In brief, the style of C++ code added to the library should conform to what is
already there. If using Eclipse, the custom code style file (see
\secref{Using_Eclipse}{Using Eclipse}) is a good start.

C++ code written in the library should conform to the ``Kernigan and Ritchie''
style, indenting with two spaces and never tabs.
