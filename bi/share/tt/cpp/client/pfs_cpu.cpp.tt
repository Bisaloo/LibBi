[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
## $Rev$
## $Date$
%]

[%-PROCESS client/misc/header.cpp.tt-%]

#include "model/[% class_name %].hpp"

#include "bi/random/Random.hpp"
#include "bi/method/ParticleFilterSmoother.hpp"
#include "bi/ode/IntegratorConstants.hpp"
#include "bi/buffer/ParticleFilterNetCDFBuffer.hpp"
#include "bi/buffer/ParticleSmootherNetCDFBuffer.hpp"
#include "bi/misc/TicToc.hpp"

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <cstdlib>
#include <sys/time.h>
#include <getopt.h>

#define LOCATION ON_HOST

int main(int argc, char* argv[]) {
  using namespace bi;

  /* model type */
  typedef [% class_name %] model_type;

  /* command line arguments */
  [% read_argv(client) %]

  /* MPI init */
  #ifdef ENABLE_MPI
  boost::mpi::environment env(argc, argv);
  #endif
  
  /* NetCDF init */
  NcError ncErr(NcError::silent_nonfatal);
  
  /* bi init */
  bi_init(THREADS);

  /* model */
  model_type m;
  
  /* random number generator */
  Random rng(SEED);

  /* inputs */
  ParticleFilterNetCDFBuffer in(m, FILTER_FILE, NetCDFBuffer::READ_ONLY);

  /* state and intermediate results */
  const int P = in.size1();
  const int T = in.size2();
  State<model_type,LOCATION> s(P);
  BI_ASSERT(P == s.size());

  /* output */
  ParticleSmootherNetCDFBuffer* out = NULL;
  if (ENABLE_OUTPUT) {
    out = new ParticleSmootherNetCDFBuffer(m, P, T, OUTPUT_FILE, NetCDFBuffer::REPLACE);
  }

  /* smoother */
  BOOST_AUTO(smoother, (ParticleFilterSmootherFactory<bi::Location,STATIC_SHARED>::create(m, out)));

  /* smooth */
  [% IF gperftools %]
  ProfilerStart(GPERFTOOLS_FILE.c_str());
  [% END %]
  TicToc timer;

  smoother->smooth(s, &in);
  synchronize();

  /* output timing results */
  if (ENABLE_TIMING) {
    std::cout << timer.toc() << std::endl;
  }
  [% IF gperftools %]
  ProfilerStop();
  [% END %]

  delete smoother;
  delete out;

  return 0;
}
