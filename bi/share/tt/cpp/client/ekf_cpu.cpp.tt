[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
## $Rev$
## $Date$
%]

[%-PROCESS client/misc/header.cpp.tt-%]
[%-PROCESS macro.hpp.tt-%]

#include "model/[% class_name %].hpp"

#include "bi/random/Random.hpp"
#include "bi/method/ExtendedKalmanFilter.hpp"
#include "bi/method/Simulator.hpp"
#include "bi/method/Forcer.hpp"
#include "bi/method/Observer.hpp"
#include "bi/buffer/SparseInputNetCDFBuffer.hpp"
#include "bi/buffer/KalmanFilterNetCDFBuffer.hpp"
#include "bi/misc/TicToc.hpp"

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <cstdlib>
#include <sys/time.h>
#include <getopt.h>

#ifdef ENABLE_CUDA
#define LOCATION ON_DEVICE
#else
#define LOCATION ON_HOST
#endif

int main(int argc, char* argv[]) {
  using namespace bi;

  /* model type */
  typedef [% class_name %] model_type;
  
  /* command line arguments */
  [% read_argv(client) %]

  /* MPI init */
  #ifdef ENABLE_MPI
  boost::mpi::environment env(argc, argv);
  #endif
  
  /* NetCDF init */
  NcError ncErr(NcError::silent_nonfatal);
  
  /* bi init */
  bi_init(THREADS);

  /* model */
  model_type m;
  
  /* random number generator */
  Random rng(SEED);

  /* state and intermediate results */
  P = 1; // force for Kalman filter
  State<model_type,LOCATION> s(P);
  P = s.size(); // may change according to implementation

  /* inputs */
  SparseInputNetCDFBuffer *bufInput = NULL, *bufInit = NULL, *bufObs = NULL;
  if (!INPUT_FILE.empty()) {
    bufInput = new SparseInputNetCDFBuffer(m, INPUT_FILE, INPUT_NS, INPUT_NP);
  }
  if (!INIT_FILE.empty()) {
    bufInit = new SparseInputNetCDFBuffer(m, INIT_FILE, INIT_NS, INIT_NP);
  }
  if (!OBS_FILE.empty()) {
    bufObs = new SparseInputNetCDFBuffer(m, OBS_FILE, OBS_NS, OBS_NP);
  }

  /* output */
  const int Y = (bufObs == NULL) ? K + 1 : bufObs->countTimes(START_TIME, T, K);

  KalmanFilterNetCDFBuffer* bufOutput;
  if (ENABLE_OUTPUT) {
    bufOutput = new KalmanFilterNetCDFBuffer(m, P, Y, OUTPUT_FILE, NetCDFBuffer::REPLACE);
  } else {
    bufOutput = NULL;
  }
  
  /* simulator */
  BOOST_AUTO(in, ForcerFactory<LOCATION>::create(bufInput));
  BOOST_AUTO(obs, ObserverFactory<LOCATION>::create(bufObs));
  BOOST_AUTO(sim, SimulatorFactory::create(m, in, obs));
  
  /* filter */
  BOOST_AUTO(filter, ExtendedKalmanFilterFactory::create(m, sim, bufOutput));

  /* filter */
  [% IF client.get_named_arg('with-gperftools') %]
  ProfilerStart(GPERFTOOLS_FILE.c_str());
  [% END %]
  TicToc timer;  
  
  filter->filter(rng, START_TIME, T, K, s, bufInit);
  synchronize();

  /* output timing results */
  if (ENABLE_TIMING) {
    std::cout << timer.toc() << std::endl;
  }
  [% IF client.get_named_arg('with-gperftools') %]
  ProfilerStop();
  [% END %]

  delete filter;
  //delete out;
  delete sim;
  delete obs;
  delete in;
  delete bufOutput;
  delete bufObs;
  delete bufInit;
  delete bufInput;

  return 0;
}
