[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
## $Rev$
## $Date$
%]

[% PROCESS macro.hpp.tt %]

[%-class_name = 'Var' _ var.get_name-%]
/**
 * @file
 *
 * @author Generated by genbi
 * $Rev$
 * $Date$
 */
#ifndef GENBI_[% class_name %]_HPP [%# don't upper class_name here, as causes clash when variable names differ by case only %]
#define GENBI_[% class_name %]_HPP

#include "bi/model/Var.hpp"
#include "bi/cuda/cuda.hpp"

[% FOREACH dim IN var.get_dims.unique-%]
#include "../dim/Dim[% dim.get_name %].hpp"
[% END-%]

[% create_var_coord(var) %]

/**
 * Variable: [% var.get_name %].
 */
class [% class_name %] : public bi::Var {
public:
  /**
   * Coordinate type.
   */
  typedef Coord[% var.get_name %] coord_type;

  /**
   * Constructor.
   */
  [% class_name %]();

  /**
   * Get name of the variable.
   *
   * @return Name of the variable.
   */
  static const char* getName();

  /**
   * Get the name used for the variable in input files.
   *
   * @return Input name of the variable.
   */
  static const char* getInputName();

  /**
   * Get the name used for the variable in output files.
   *
   * @return Output name of the variable.
   */
  static const char* getOutputName();

  /**
   * Should the variable be included in input files?
   */
  static bool hasInput();

  /**
   * Should the variable be included in output files?
   */
  static bool hasOutput();
  
  /**
   * Should the variable be output only once, not at every time?
   */
  static bool getOutputOnce();

  /**
   * Initialise dimensions. Called by Model::addVar() after construction.
   *
   * @tparam B Model type.
   *
   * @param m Model.
   */
  template<class B>
  void initDims(const B& m);
    
  /**
   * Id.
   */
  static const int ID = [% var.get_id %];

  /**
   * Size.
   */
  static const int START = [% model.get_var_start(var) %];
  
  /**
   * Size.
   */
  static const int SIZE = [% var.get_size %];

  /**
   * Number of dimensions.
   */
  static const int NUM_DIMS = [% var.num_dims %];
  
  [% IF var.num_dims == 2 %]
  /**
   * Number of rows.
   */
  static const int ROWS = [% var.get_dims.0.get_size %];
  
  /**
   * Number of columns.
   */
  static const int COLS = [% var.get_dims.1.get_size %];
  [%-END %]
  
  /**
   * Type.
   */
  static const bi::VarType TYPE = bi::
  [%-IF var.get_type == 'state'-%]
  D_VAR
  [%-ELSIF var.get_type == 'state_aux_'-%]
  DX_VAR
  [%-ELSIF var.get_type == 'input'-%]
  F_VAR
  [%-ELSIF var.get_type == 'noise'-%]
  R_VAR
  [%-ELSIF var.get_type == 'obs'-%]
  O_VAR
  [%-ELSIF var.get_type == 'param'-%]
  P_VAR
  [%-ELSIF var.get_type == 'param_aux_'-%]
  PX_VAR
  [%-END-%];
};

inline [% class_name %]::[% class_name %]() : bi::Var(*this) {
  //
}

inline const char* [% class_name %]::getName() {
  return "[% var.get_name %]";
}

inline const char* [% class_name %]::getInputName() {
  return [% var.get_named_arg('input_name').to_cpp %];
}

inline const char* [% class_name %]::getOutputName() {
  return [% var.get_named_arg('output_name').to_cpp %];
}

inline bool [% class_name %]::hasInput() {
  return [% var.get_named_arg('has_input').to_cpp %];
}

inline bool [% class_name %]::hasOutput() {
  return [% var.get_named_arg('has_output').to_cpp %];
}

inline bool [% class_name %]::getOutputOnce() {
  return [% var.get_named_arg('output_once').eval_const %];
}

template<class B>
inline void [% class_name %]::initDims(const B& m) {
  [%-FOREACH dim IN var.get_dims %]
  dims[[% loop.index %]] = m.getDim([% dim.get_id %]);
  [%-END %]
}

#endif
