[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
## $Rev$
## $Date$
%]

[%-PROCESS client/misc/header.cpp.tt-%]
[%-PROCESS macro.hpp.tt-%]

#include "bi/resampler/MultinomialResampler.hpp"
#include "bi/resampler/MetropolisResampler.hpp"
#include "bi/resampler/RejectionResampler.hpp"
#include "bi/resampler/KernelResampler.hpp"
#include "bi/resampler/StratifiedResampler.hpp"
#include "bi/random/Random.hpp"
#include "bi/pdf/GaussianPdf.hpp"
#include "bi/math/loc_vector.hpp"
#include "bi/math/loc_matrix.hpp"
#include "bi/misc/TicToc.hpp"

#include <iostream>
#include <string>
#include <unistd.h>
#include <getopt.h>

#include "netcdfcpp.h"

#ifndef ENABLE_CUDA
#define LOCATION ON_HOST
#else
#define LOCATION ON_DEVICE
#endif

int main(int argc, char* argv[]) {
  using namespace bi;

  /* command line arguments */
  [% read_argv(client) %]

  /* MPI init */
  #ifdef ENABLE_MPI
  boost::mpi::environment env(argc, argv);
  #endif
  
  /* bi init */
  bi_init(THREADS);

  /* random number generator */
  Random rng(SEED);

  /* set up output file */
  NcFile* out = NULL;
  NcVar* rmseVar = NULL;
  NcVar* time1Var = NULL;
  NcVar* time2Var = NULL;
  NcVar* time3Var = NULL;
  if (!OUTPUT_FILE.empty()) {
    out = new NcFile(OUTPUT_FILE.c_str(), NcFile::Replace);
	
    NcDim* zDim = out->add_dim("z", ZS);
    NcDim* PDim = out->add_dim("P", PS);
    NcDim* repDim = out->add_dim("rep", REPS);
	  
    rmseVar = out->add_var("rmse", ncDouble, zDim, PDim, repDim);
    time1Var = out->add_var("time1", ncInt, zDim, PDim, repDim);
    time2Var = out->add_var("time2", ncInt, zDim, PDim, repDim);
    time3Var = out->add_var("time3", ncInt, zDim, PDim, repDim);
  }
	
  /* resampler */
  [% IF client.get_named_arg('resampler') == 'metropolis' %]
  MetropolisResampler resam(C);
  [% ELSIF client.get_named_arg('resampler') == 'rejection' %]
  RejectionResampler resam;
  [% ELSIF client.get_named_arg('resampler') == 'multinomial' %]
  MultinomialResampler resam(ENABLE_SORT);
  [% ELSE %]
  StratifiedResampler resam(ENABLE_SORT);
  [% END %]

  /* buffers for weight-sets and results */
  typedef typename loc_vector<LOCATION,real>::type vector_type;
  typedef typename loc_matrix<LOCATION,real>::type matrix_type;
  typedef typename loc_vector<LOCATION,int>::type int_vector_type;
  typedef typename loc_matrix<LOCATION,int>::type int_matrix_type;
  
  /* generate particles */
  int maxP = std::pow(2, 4 + PS);
  int actualP = 0;
  
  matrix_type x(maxP*REPS, 1);  // particles
  matrix_type lW(maxP, REPS); // log-weights
  int_matrix_type times1(REPS, PS), times2(REPS, PS), times3(REPS, PS);
  matrix_type rmses(REPS, PS);
  int_vector_type a(maxP);
  int_vector_type o(maxP);
  
  GaussianPdf<vector_type,matrix_type> f(1), g(1);
  f.samples(rng, x);
  
  /* test */
  [% IF gperftools %]
  ProfilerStart(GPERFTOOLS_FILE.c_str());
  [% END %]
  TicToc timer;
  int z, p, rep, time1, time2, time3;
  real rmse;
  for (z = 0; z < ZS; ++z) {
    /* generate log-weights */
    if (z > 0) {
      addscal_elements(vec(x), 1.0);
    }
    g.logDensities(x, vec(lW), true);
  
    /* test on weight sets */
    for (p = 0; p < PS; ++p) {
      actualP = std::pow(2, p + 5);
      BOOST_AUTO(as, subrange(a, 0, actualP));
      BOOST_AUTO(os, subrange(o, 0, actualP));
    
      for (rep = 0; rep < REPS; ++rep) {
        BOOST_AUTO(lws, subrange(column(lW, rep), 0, actualP));
        
        synchronize();
        timer.tic();
        
        [% IF client.get_named_arg('resampler') == 'stratified' %]
        if (ENABLE_SORT) {
          bi::sort(lws);
        }
        synchronize();
        time1 = timer.toc();
        
        resam.offspring(rng, lws, os, actualP);
        synchronize();
        time2 = timer.toc();
        
        resam.offspringToAncestors(os, as);
        resam.permute(as);
        synchronize();
        time3 = timer.toc();
        [% ELSIF client.get_named_arg('resampler') == 'rejection' %]
        synchronize();
        time1 = timer.toc();
        
        real maxLogWeight = -BI_HALF_LOG_TWO_PI;
        resam.ancestors(rng, lws, as, maxLogWeight);
        synchronize();
        time2 = timer.toc();

        resam.permute(as);
        resam.ancestorsToOffspring(as, os);
        synchronize();
        time3 = timer.toc();
        [% ELSIF client.get_named_arg('resampler') == 'metropolis' %]
        synchronize();
        time1 = timer.toc();

        real W = sumexp_reduce(lws);
        real wmax = bi::exp(max_reduce(lws));
        real beta = 1.0/actualP;
        real alpha = W/wmax;
        real epsilon = 1.0e-3;
        real lambda = 1.0 - alpha - beta;
        real steps = bi::log(epsilon*(alpha + beta)/bi::max(alpha, beta))/bi::log(lambda);
        resam.ancestors(rng, lws, as, static_cast<int>(bi::floor(steps)));
        synchronize();
        time2 = timer.toc();
        
        resam.permute(as);
        resam.ancestorsToOffspring(as, os);
        synchronize();
        time3 = timer.toc();
        [% ELSE %]
        synchronize();
        time1 = timer.toc();

        resam.ancestors(rng, lws, as);
        synchronize();
        time2 = timer.toc();
        
        resam.permute(as);
        resam.ancestorsToOffspring(as, os);
        synchronize();
        time3 = timer.toc();
        [% END %]
        
        rmse = bi::sqrt(resam.error(lws, os));
        
        rmses(rep, p) = rmse;
        times1(rep, p) = time1;
        times2(rep, p) = time2;
        times3(rep, p) = time3;
      }
      
      /* output */
      if (out != NULL) {
        rmseVar->set_cur(z, 0, 0);
        rmseVar->put(rmses.buf(), 1, PS, REPS);
        time1Var->set_cur(z, 0, 0);
        time1Var->put(times1.buf(), 1, PS, REPS);
        time2Var->set_cur(z, 0, 0);
        time2Var->put(times2.buf(), 1, PS, REPS);
        time3Var->set_cur(z, 0, 0);
        time3Var->put(times3.buf(), 1, PS, REPS);
      }
    }
  }

  [% IF gperftools %]
  ProfilerStop();
  [% END %]
  
  /* clean up */
  out->sync();
  delete out;

  return 0;
}

