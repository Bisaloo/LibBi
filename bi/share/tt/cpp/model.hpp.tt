[%
## @file
##
## @author Lawrence Murray <lawrence.murray@csiro.au>
## $Rev$
## $Date$
%]

[%-class_name = "Model" _ model.get_name-%]
/**
 * @file
 *
 * @author Generated by genbi
 * $Rev$
 * $Date$
 */
#ifndef GENBI_[% class_name | upper %]_HPP
#define GENBI_[% class_name | upper %]_HPP

[% FOREACH dim IN model.get_dims-%]
#include "dim/Dim[% dim.get_name %].hpp"
[% END-%]

[% FOREACH var IN model.get_vars-%]
#include "var/Var[% var.get_name %].hpp"
[% END-%]

#include "bi/model/Model.hpp"
#include "bi/state/State.hpp"
#include "bi/random/Random.hpp"
#include "bi/typelist/macro_typelist.hpp"
#include "bi/typelist/macro_typetree.hpp"
#include "bi/buffer/Mask.hpp"

[%
# mapping of verbose types to abbreviations
TYPES = {
  'state' => 'd',
  'state_aux_' => 'dx',
  'input' => 'f',
  'noise' => 'r',
  'obs' => 'o',
  'param' => 'p',
  'param_aux_' => 'px'
};

# top-level dynamic blocks
DYNAMIC_BLOCKS = ['transition', 'lookahead_transition'];

# top-level static/instant blocks
STATIC_BLOCKS = ['parameter', 'initial', 'observation', 'proposal_parameter', 'proposal_initial'];

# top-evel sparse blocks
SPARSE_BLOCKS = ['observation', 'lookahead_observation'];
%]

/**
 * Model [% model.get_name %].
 */
class [% class_name %] : public bi::Model {
public:
  [%-FOREACH dim IN model.get_dims %]
  /**
   * Size of [% dim.get_name %] dimension.
   */
  static const int N[% dim.get_name | upper %] = [% dim.get_size %];
  [% END-%]
  
  /**
   * Number of dimensions.
   */
  static const int Ndims = [% model.num_dims %];
  
  [%-FOREACH type IN TYPES.keys %]
  /**
   * Size of [% type %] net.
   */
  static const int N[% TYPES.$type | upper %] = [% model.get_size(type) %];
  
  /**
   * Number of variables in [% type %] net.
   */
  static const int C[% TYPES.$type | upper %] = [% model.num_vars(type) %];
  [% END %]
  
  /**
   * Constructor.
   */
  [% class_name %]();

  [% IF model.is_block('transition') %]
  /**
   * Get discrete time step of transition model.
   *
   * @return Time step.
   */
  static real getDelta();
  [% END %]
  
  [% IF model.is_named_arg('F_start_') && model.is_named_arg('F_size_') %]
  /**
   * Get starting index of transition model Jacobian variables.
   *
   * @return Starting index.
   */
  static int getFStart();

  /**
   * Get size of transition model Jacobian variables.
   *
   * @return Size.
   */
  static int getFSize();
  [% END %]

  [% IF model.is_named_arg('G_start_') && model.is_named_arg('G_size_') %]
  /**
   * Get starting index of observation model Jacobian variables.
   *
   * @return Starting index.
   */
  static int getGStart();

  /**
   * Get size of observation model Jacobian variables.
   *
   * @return Size.
   */
  static int getGSize();
  [% END %]

  [% IF model.is_named_arg('Q_start_') && model.is_named_arg('Q_size_') %]
  /**
   * Get starting index of square-root covariance of state variables.
   *
   * @return Starting index.
   */
  static int getQStart();

  /**
   * Get size of square-root covariance of state variables.
   *
   * @return Size.
   */
  static int getQSize();
  [% END %]

  [% IF model.is_named_arg('R_start_') && model.is_named_arg('R_size_') %]
  /**
   * Get starting index of square-root covariance of observed variables.
   *
   * @return Starting index.
   */
  static int getRStart();

  /**
   * Get size of square-root covariance of observed variables.
   *
   * @return Size.
   */
  static int getRSize();
  [% END %]

  [%-FOREACH toplevel IN DYNAMIC_BLOCKS %]
  /**
   * Deterministically simulate the @c [% toplevel %] block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<class T1, bi::Location L>
  static void [% toplevel | to_camel_case %]Simulate(const T1 t1,
      const T1 t2, bi::State<[% class_name %],L>& s);
  
  /**
   * Stochastically simulate the @c [% toplevel %] block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<class T1, bi::Location L>
  static void [% toplevel | to_camel_case %]Samples(bi::Random& rng,
      const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s);

  /**
   * Compute the log-density of query point(s) under the @c [% toplevel %]
   * block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point(s). On output, contains the
   * ending state, consistent with the query point(s).
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<class T1, bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]LogDensities(const T1 t1,
      const T1 t2, bi::State<[% class_name %],L>& s, V1 lp);

  /**
   * Compute the maximum log-density of query point(s) under the
   * @c [% toplevel %] block.
   *
   * @tparam T1 Scalar type.
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param t1 Starting time.
   * @param t2 Ending time.
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point(s). On output, contains the
   * ending state, consistent with the query point(s).
   * @param[in,out] lp Maximum log-density. On output, contains the updated
   * maximum log-density (by addition).
   */
  template<class T1, bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]MaxLogDensities(const T1 t1,
      const T1 t2, bi::State<[% class_name %],L>& s, V1 lp);
  [% END %]
  
  [%-FOREACH toplevel IN STATIC_BLOCKS %]
  /**
   * Deterministically simulate the @c [% toplevel %] block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void [% toplevel | to_camel_case %]Simulate(bi::State<[% class_name %],L>& s);

  /**
   * Stochastically simulate the @c [% toplevel %] block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   */
  template<bi::Location L>
  static void [% toplevel | to_camel_case %]Samples(bi::Random& rng, bi::State<[% class_name %],L>& s);
  
  /**
   * Compute the log-density of query point(s) under the @c [% toplevel %]
   * block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point(s)(s). On output, contains the
   * ending state, consistent with the query point(s).
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]LogDensities(bi::State<[% class_name %],L>& s, V1 lp);

  /**
   * Compute the maximum log-density of query point(s) under the
   * @c [% toplevel %] block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point(s)(s). On output, contains the
   * ending state, consistent with the query point(s).
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]MaxLogDensities(bi::State<[% class_name %],L>& s, V1 lp);
  [% END-%]

  [%-FOREACH toplevel IN SPARSE_BLOCKS %]
  /**
   * Deterministically, and sparsely, simulate the @c [% toplevel %] block.
   *
   * @tparam L Location.
   *
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   */
  template<bi::Location L>
  static void [% toplevel | to_camel_case %]Simulate(bi::State<[% class_name %],L>& s, const bi::Mask<L>& mask);

  /**
   * Stochastically, and sparsely, simulate the @c [% toplevel %] block.
   *
   * @tparam L Location.
   *
   * @param rng Random number generator.
   * @param[in,out] s State. On input, contains the starting state, on
   * output, contains the ending state.
   * @param mask Sparsity mask.
   */
  template<bi::Location L>
  static void [% toplevel | to_camel_case %]Samples(bi::Random& rng, bi::State<[% class_name %],L>& s, const bi::Mask<L>& mask);
  
  /**
   * Sparsely compute the log-density of query point(s) under the
   * @c [% toplevel %] block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point(s)(s). On output, contains the
   * ending state, consistent with the query point(s).
   * @param mask Sparsity mask.
   * @param[in,out] lp Log-density. On output, contains the updated 
   * log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]LogDensities(bi::State<[% class_name %],L>& s, const bi::Mask<L>& mask, V1 lp);

  /**
   * Sparsely compute the maximum log-density of query point(s) under the
   * @c [% toplevel %] block.
   *
   * @tparam L Location.
   * @tparam V1 Vector type.
   *
   * @param[in,out] s State. On input, contains the starting state and, in
   * the alternative buffers, the query point(s)(s). On output, contains the
   * ending state, consistent with the query point(s).
   * @param mask Sparsity mask.
   * @param[in,out] lp Maximum log-density. On output, contains the updated
   * maximum log-density (by addition).
   */
  template<bi::Location L, class V1>
  static void [% toplevel | to_camel_case %]MaxLogDensities(bi::State<[% class_name %],L>& s, const bi::Mask<L>& mask, V1 lp);
  [% END-%]
   
  [% IF model.is_block('transition') %]
  /**
   * Is current time on the delta of the transition model?
   *
   * @param t1 Current time.
   * @param t2 Next time.
   *
   * @return True if @p t1 is on the delta of the transition model.
   */
  template<class T1>
  static bool onDelta(const T1 t1, const T1 t2);
  [% END %]

private:
  /*
   * Dimensions
   */
  [%-FOREACH dim IN model.get_dims %]
  Dim[% dim.get_name %] dim[% dim.get_name %];
  [%-END %]

  /*
   * Variables
   */
  [%-FOREACH var IN model.get_vars %]
  Var[% var.get_name %] var[% var.get_name %];
  [%-END %]
};

[% FOREACH block IN model.get_blocks-%]
#include "block/Block[% block.get_id %].hpp"
[% END-%]

#include "bi/method/misc.hpp"

[% IF model.is_block('transition') %]
inline real [% class_name %]::getDelta() {
  return Block[% model.get_block('transition').get_id %]::getDelta();
}
[% END %]

[% IF model.is_named_arg('F_start_') && model.is_named_arg('F_size_') %]
inline int [% class_name %]::getFStart() {
  return [% model.get_named_arg('F_start_').eval_const %];
}

inline int [% class_name %]::getFSize() {
  return [% model.get_named_arg('F_size_').eval_const %];
}
[% END %]

[% IF model.is_named_arg('G_start_') && model.is_named_arg('G_size_') %]
inline int [% class_name %]::getGStart() {
  return [% model.get_named_arg('G_start_').eval_const %];
}

inline int [% class_name %]::getGSize() {
  return [% model.get_named_arg('G_size_').eval_const %];
}
[% END %]

[% IF model.is_named_arg('Q_start_') && model.is_named_arg('Q_size_') %]
inline int [% class_name %]::getQStart() {
  return [% model.get_named_arg('Q_start_').eval_const %];
}

inline int [% class_name %]::getQSize() {
  return [% model.get_named_arg('Q_size_').eval_const %];
}
[% END %]

[% IF model.is_named_arg('R_start_') && model.is_named_arg('R_size_') %]
inline int [% class_name %]::getRStart() {
  return [% model.get_named_arg('R_start_').eval_const %];
}

inline int [% class_name %]::getRSize() {
  return [% model.get_named_arg('R_size_').eval_const %];
}
[% END %]

[%-FOREACH toplevel IN DYNAMIC_BLOCKS %]
template<class T1, bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Simulate(const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::simulate(t1, t2, onDelta(t1, t2), s);
  [% ELSE %]
  BI_ERROR(false, "Attempt to deterministically simulate stochastic model");
  [%-END %]
}

template<class T1, bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Samples(bi::Random& rng, const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s) {
  [%-IF model.is_block(toplevel)-%]
  Block[% model.get_block(toplevel).get_id %]::samples(rng, t1, t2, onDelta(t1, t2), s);
  [% ELSE %]
  //
  [%-END %]
}

template<class T1, bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]LogDensities(const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s, V1 lp) {
  [%-IF model.is_block(toplevel)-%]
  Block[% model.get_block(toplevel).get_id %]::logDensities(t1, t2, onDelta(t1, t2), s, lp);
  [% ELSE %]
  //
  [%-END %]
}

template<class T1, bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]MaxLogDensities(const T1 t1, const T1 t2, bi::State<[% class_name %],L>& s, V1 lp) {
  [%-IF model.is_block(toplevel)-%]
  Block[% model.get_block(toplevel).get_id %]::maxLogDensities(t1, t2, onDelta(t1, t2), s, lp);
  [% ELSE %]
  //
  [%-END %]
}
[% END %]

[%-FOREACH toplevel IN STATIC_BLOCKS %]
template<bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Simulate(bi::State<[% class_name %],L>& s) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::simulate(s);
  [% ELSE %]
  BI_ERROR(false, "Attempt to deterministically simulate stochastic model");
  [%-END %]
}

template<bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Samples(bi::Random& rng, bi::State<[% class_name %],L>& s) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::samples(rng, s);
  [% ELSE %]
  //
  [%-END %]
}

template<bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]LogDensities(bi::State<[% class_name %],L>& s, V1 lp) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::logDensities(s, lp);
  [% ELSE %]
  //
  [%-END %]
}

template<bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]MaxLogDensities(bi::State<[% class_name %],L>& s, V1 lp) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::maxLogDensities(s, lp);
  [% ELSE %]
  //
  [%-END %]
}
[% END %]

[%-FOREACH toplevel IN SPARSE_BLOCKS %]
template<bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Simulate(bi::State<[% class_name %],L>& s,
    const bi::Mask<L>& mask) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::simulate(s, mask);
  [% ELSE %]
  BI_ERROR(false, "Attempt to deterministically simulate stochastic model");
  [%-END %]
}

template<bi::Location L>
void [% class_name %]::[% toplevel | to_camel_case %]Samples(bi::Random& rng, bi::State<[% class_name %],L>& s,
    const bi::Mask<L>& mask) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::samples(rng, s, mask);
  [% ELSE %]
  //
  [%-END %]
}

template<bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]LogDensities(bi::State<[% class_name %],L>& s,
    const bi::Mask<L>& mask, V1 lp) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::logDensities(s, mask, lp);
  [% ELSE %]
  //
  [%-END %]
}

template<bi::Location L, class V1>
void [% class_name %]::[% toplevel | to_camel_case %]MaxLogDensities(bi::State<[% class_name %],L>& s,
    const bi::Mask<L>& mask, V1 lp) {
  [%-IF model.is_block(toplevel) %]
  Block[% model.get_block(toplevel).get_id %]::maxLogDensities(s, mask, lp);
  [% ELSE %]
  //
  [%-END %]
}
[% END %]

[% IF model.is_block('transition') %]
template<class T1>
inline bool [% class_name %]::onDelta(const T1 t1, const T1 t2) {
  T1 sgn = (t2 >= t1) ? 1.0 : -1.0;
  T1 nextDelta = sgn*bi::ge_step(t1, sgn*getDelta());
  return sgn*t1 >= sgn*nextDelta;
}
[% END %]

#endif
